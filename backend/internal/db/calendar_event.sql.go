// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: calendar_event.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountEventsForContact = `-- name: CountEventsForContact :one
SELECT COUNT(*) FROM calendar_event
WHERE $1::uuid = ANY(matched_contact_ids)
  AND status != 'cancelled'
`

// Count events for a specific contact
func (q *Queries) CountEventsForContact(ctx context.Context, contactID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountEventsForContact, contactID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const DeleteEventsByAccount = `-- name: DeleteEventsByAccount :exec
DELETE FROM calendar_event
WHERE google_account_id = $1
`

// Delete all events for a Google account (used when revoking access)
func (q *Queries) DeleteEventsByAccount(ctx context.Context, googleAccountID string) error {
	_, err := q.db.Exec(ctx, DeleteEventsByAccount, googleAccountID)
	return err
}

const GetCalendarEventByGcalID = `-- name: GetCalendarEventByGcalID :one
SELECT id, gcal_event_id, gcal_calendar_id, google_account_id, title, description, location, start_time, end_time, all_day, status, user_response, organizer_email, attendees, matched_contact_ids, synced_at, last_contacted_updated, created_at, updated_at FROM calendar_event
WHERE gcal_event_id = $1
  AND gcal_calendar_id = $2
  AND google_account_id = $3
LIMIT 1
`

type GetCalendarEventByGcalIDParams struct {
	GcalEventID     string `json:"gcal_event_id"`
	GcalCalendarID  string `json:"gcal_calendar_id"`
	GoogleAccountID string `json:"google_account_id"`
}

// Look up an event by its Google Calendar ID
func (q *Queries) GetCalendarEventByGcalID(ctx context.Context, arg GetCalendarEventByGcalIDParams) (*CalendarEvent, error) {
	row := q.db.QueryRow(ctx, GetCalendarEventByGcalID, arg.GcalEventID, arg.GcalCalendarID, arg.GoogleAccountID)
	var i CalendarEvent
	err := row.Scan(
		&i.ID,
		&i.GcalEventID,
		&i.GcalCalendarID,
		&i.GoogleAccountID,
		&i.Title,
		&i.Description,
		&i.Location,
		&i.StartTime,
		&i.EndTime,
		&i.AllDay,
		&i.Status,
		&i.UserResponse,
		&i.OrganizerEmail,
		&i.Attendees,
		&i.MatchedContactIds,
		&i.SyncedAt,
		&i.LastContactedUpdated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetCalendarEventByID = `-- name: GetCalendarEventByID :one
SELECT id, gcal_event_id, gcal_calendar_id, google_account_id, title, description, location, start_time, end_time, all_day, status, user_response, organizer_email, attendees, matched_contact_ids, synced_at, last_contacted_updated, created_at, updated_at FROM calendar_event
WHERE id = $1
LIMIT 1
`

// Look up an event by its UUID
func (q *Queries) GetCalendarEventByID(ctx context.Context, id pgtype.UUID) (*CalendarEvent, error) {
	row := q.db.QueryRow(ctx, GetCalendarEventByID, id)
	var i CalendarEvent
	err := row.Scan(
		&i.ID,
		&i.GcalEventID,
		&i.GcalCalendarID,
		&i.GoogleAccountID,
		&i.Title,
		&i.Description,
		&i.Location,
		&i.StartTime,
		&i.EndTime,
		&i.AllDay,
		&i.Status,
		&i.UserResponse,
		&i.OrganizerEmail,
		&i.Attendees,
		&i.MatchedContactIds,
		&i.SyncedAt,
		&i.LastContactedUpdated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListEventsByAccountAndDateRange = `-- name: ListEventsByAccountAndDateRange :many
SELECT id, gcal_event_id, gcal_calendar_id, google_account_id, title, description, location, start_time, end_time, all_day, status, user_response, organizer_email, attendees, matched_contact_ids, synced_at, last_contacted_updated, created_at, updated_at FROM calendar_event
WHERE google_account_id = $1
  AND start_time >= $2
  AND start_time <= $3
  AND status != 'cancelled'
ORDER BY start_time ASC
`

type ListEventsByAccountAndDateRangeParams struct {
	GoogleAccountID string             `json:"google_account_id"`
	StartTime       pgtype.Timestamptz `json:"start_time"`
	StartTime_2     pgtype.Timestamptz `json:"start_time_2"`
}

// List events by Google account within a date range
func (q *Queries) ListEventsByAccountAndDateRange(ctx context.Context, arg ListEventsByAccountAndDateRangeParams) ([]*CalendarEvent, error) {
	rows, err := q.db.Query(ctx, ListEventsByAccountAndDateRange, arg.GoogleAccountID, arg.StartTime, arg.StartTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CalendarEvent{}
	for rows.Next() {
		var i CalendarEvent
		if err := rows.Scan(
			&i.ID,
			&i.GcalEventID,
			&i.GcalCalendarID,
			&i.GoogleAccountID,
			&i.Title,
			&i.Description,
			&i.Location,
			&i.StartTime,
			&i.EndTime,
			&i.AllDay,
			&i.Status,
			&i.UserResponse,
			&i.OrganizerEmail,
			&i.Attendees,
			&i.MatchedContactIds,
			&i.SyncedAt,
			&i.LastContactedUpdated,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListEventsForContact = `-- name: ListEventsForContact :many
SELECT id, gcal_event_id, gcal_calendar_id, google_account_id, title, description, location, start_time, end_time, all_day, status, user_response, organizer_email, attendees, matched_contact_ids, synced_at, last_contacted_updated, created_at, updated_at FROM calendar_event
WHERE $1::uuid = ANY(matched_contact_ids)
  AND status != 'cancelled'
ORDER BY start_time DESC
LIMIT $3 OFFSET $2
`

type ListEventsForContactParams struct {
	ContactID   pgtype.UUID `json:"contact_id"`
	EventOffset int32       `json:"event_offset"`
	EventLimit  int32       `json:"event_limit"`
}

// List calendar events involving a specific contact
func (q *Queries) ListEventsForContact(ctx context.Context, arg ListEventsForContactParams) ([]*CalendarEvent, error) {
	rows, err := q.db.Query(ctx, ListEventsForContact, arg.ContactID, arg.EventOffset, arg.EventLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CalendarEvent{}
	for rows.Next() {
		var i CalendarEvent
		if err := rows.Scan(
			&i.ID,
			&i.GcalEventID,
			&i.GcalCalendarID,
			&i.GoogleAccountID,
			&i.Title,
			&i.Description,
			&i.Location,
			&i.StartTime,
			&i.EndTime,
			&i.AllDay,
			&i.Status,
			&i.UserResponse,
			&i.OrganizerEmail,
			&i.Attendees,
			&i.MatchedContactIds,
			&i.SyncedAt,
			&i.LastContactedUpdated,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListPastEventsNeedingUpdate = `-- name: ListPastEventsNeedingUpdate :many
SELECT id, gcal_event_id, gcal_calendar_id, google_account_id, title, description, location, start_time, end_time, all_day, status, user_response, organizer_email, attendees, matched_contact_ids, synced_at, last_contacted_updated, created_at, updated_at FROM calendar_event
WHERE last_contacted_updated = FALSE
  AND status = 'confirmed'
  AND end_time < $1
  AND array_length(matched_contact_ids, 1) > 0
ORDER BY end_time ASC
LIMIT $2
`

type ListPastEventsNeedingUpdateParams struct {
	EndTime pgtype.Timestamptz `json:"end_time"`
	Limit   int32              `json:"limit"`
}

// List past events that haven't updated last_contacted yet
func (q *Queries) ListPastEventsNeedingUpdate(ctx context.Context, arg ListPastEventsNeedingUpdateParams) ([]*CalendarEvent, error) {
	rows, err := q.db.Query(ctx, ListPastEventsNeedingUpdate, arg.EndTime, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CalendarEvent{}
	for rows.Next() {
		var i CalendarEvent
		if err := rows.Scan(
			&i.ID,
			&i.GcalEventID,
			&i.GcalCalendarID,
			&i.GoogleAccountID,
			&i.Title,
			&i.Description,
			&i.Location,
			&i.StartTime,
			&i.EndTime,
			&i.AllDay,
			&i.Status,
			&i.UserResponse,
			&i.OrganizerEmail,
			&i.Attendees,
			&i.MatchedContactIds,
			&i.SyncedAt,
			&i.LastContactedUpdated,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListUpcomingEventsForContact = `-- name: ListUpcomingEventsForContact :many
SELECT id, gcal_event_id, gcal_calendar_id, google_account_id, title, description, location, start_time, end_time, all_day, status, user_response, organizer_email, attendees, matched_contact_ids, synced_at, last_contacted_updated, created_at, updated_at FROM calendar_event
WHERE $1::uuid = ANY(matched_contact_ids)
  AND status != 'cancelled'
  AND start_time > $2
ORDER BY start_time ASC
LIMIT $3
`

type ListUpcomingEventsForContactParams struct {
	ContactID  pgtype.UUID        `json:"contact_id"`
	AfterTime  pgtype.Timestamptz `json:"after_time"`
	EventLimit int32              `json:"event_limit"`
}

// List upcoming calendar events for a specific contact
func (q *Queries) ListUpcomingEventsForContact(ctx context.Context, arg ListUpcomingEventsForContactParams) ([]*CalendarEvent, error) {
	rows, err := q.db.Query(ctx, ListUpcomingEventsForContact, arg.ContactID, arg.AfterTime, arg.EventLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CalendarEvent{}
	for rows.Next() {
		var i CalendarEvent
		if err := rows.Scan(
			&i.ID,
			&i.GcalEventID,
			&i.GcalCalendarID,
			&i.GoogleAccountID,
			&i.Title,
			&i.Description,
			&i.Location,
			&i.StartTime,
			&i.EndTime,
			&i.AllDay,
			&i.Status,
			&i.UserResponse,
			&i.OrganizerEmail,
			&i.Attendees,
			&i.MatchedContactIds,
			&i.SyncedAt,
			&i.LastContactedUpdated,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListUpcomingEventsWithContacts = `-- name: ListUpcomingEventsWithContacts :many
SELECT id, gcal_event_id, gcal_calendar_id, google_account_id, title, description, location, start_time, end_time, all_day, status, user_response, organizer_email, attendees, matched_contact_ids, synced_at, last_contacted_updated, created_at, updated_at FROM calendar_event
WHERE array_length(matched_contact_ids, 1) > 0
  AND status != 'cancelled'
  AND start_time > $1
ORDER BY start_time ASC
LIMIT $2 OFFSET $3
`

type ListUpcomingEventsWithContactsParams struct {
	StartTime pgtype.Timestamptz `json:"start_time"`
	Limit     int32              `json:"limit"`
	Offset    int32              `json:"offset"`
}

// List upcoming events that have matched CRM contacts
func (q *Queries) ListUpcomingEventsWithContacts(ctx context.Context, arg ListUpcomingEventsWithContactsParams) ([]*CalendarEvent, error) {
	rows, err := q.db.Query(ctx, ListUpcomingEventsWithContacts, arg.StartTime, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CalendarEvent{}
	for rows.Next() {
		var i CalendarEvent
		if err := rows.Scan(
			&i.ID,
			&i.GcalEventID,
			&i.GcalCalendarID,
			&i.GoogleAccountID,
			&i.Title,
			&i.Description,
			&i.Location,
			&i.StartTime,
			&i.EndTime,
			&i.AllDay,
			&i.Status,
			&i.UserResponse,
			&i.OrganizerEmail,
			&i.Attendees,
			&i.MatchedContactIds,
			&i.SyncedAt,
			&i.LastContactedUpdated,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const MarkLastContactedUpdated = `-- name: MarkLastContactedUpdated :exec
UPDATE calendar_event
SET last_contacted_updated = TRUE,
    updated_at = NOW()
WHERE id = $1
`

// Mark an event as having updated last_contacted for its contacts
func (q *Queries) MarkLastContactedUpdated(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, MarkLastContactedUpdated, id)
	return err
}

const UpdateMatchedContacts = `-- name: UpdateMatchedContacts :one
UPDATE calendar_event
SET matched_contact_ids = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, gcal_event_id, gcal_calendar_id, google_account_id, title, description, location, start_time, end_time, all_day, status, user_response, organizer_email, attendees, matched_contact_ids, synced_at, last_contacted_updated, created_at, updated_at
`

type UpdateMatchedContactsParams struct {
	ID                pgtype.UUID   `json:"id"`
	MatchedContactIds []pgtype.UUID `json:"matched_contact_ids"`
}

// Update the matched contact IDs for an event
func (q *Queries) UpdateMatchedContacts(ctx context.Context, arg UpdateMatchedContactsParams) (*CalendarEvent, error) {
	row := q.db.QueryRow(ctx, UpdateMatchedContacts, arg.ID, arg.MatchedContactIds)
	var i CalendarEvent
	err := row.Scan(
		&i.ID,
		&i.GcalEventID,
		&i.GcalCalendarID,
		&i.GoogleAccountID,
		&i.Title,
		&i.Description,
		&i.Location,
		&i.StartTime,
		&i.EndTime,
		&i.AllDay,
		&i.Status,
		&i.UserResponse,
		&i.OrganizerEmail,
		&i.Attendees,
		&i.MatchedContactIds,
		&i.SyncedAt,
		&i.LastContactedUpdated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpsertCalendarEvent = `-- name: UpsertCalendarEvent :one
INSERT INTO calendar_event (
    gcal_event_id,
    gcal_calendar_id,
    google_account_id,
    title,
    description,
    location,
    start_time,
    end_time,
    all_day,
    status,
    user_response,
    organizer_email,
    attendees,
    matched_contact_ids,
    synced_at,
    last_contacted_updated
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
)
ON CONFLICT (gcal_event_id, gcal_calendar_id, google_account_id)
DO UPDATE SET
    title = EXCLUDED.title,
    description = EXCLUDED.description,
    location = EXCLUDED.location,
    start_time = EXCLUDED.start_time,
    end_time = EXCLUDED.end_time,
    all_day = EXCLUDED.all_day,
    status = EXCLUDED.status,
    user_response = EXCLUDED.user_response,
    organizer_email = EXCLUDED.organizer_email,
    attendees = EXCLUDED.attendees,
    matched_contact_ids = EXCLUDED.matched_contact_ids,
    synced_at = EXCLUDED.synced_at,
    updated_at = NOW()
RETURNING id, gcal_event_id, gcal_calendar_id, google_account_id, title, description, location, start_time, end_time, all_day, status, user_response, organizer_email, attendees, matched_contact_ids, synced_at, last_contacted_updated, created_at, updated_at
`

type UpsertCalendarEventParams struct {
	GcalEventID          string             `json:"gcal_event_id"`
	GcalCalendarID       string             `json:"gcal_calendar_id"`
	GoogleAccountID      string             `json:"google_account_id"`
	Title                pgtype.Text        `json:"title"`
	Description          pgtype.Text        `json:"description"`
	Location             pgtype.Text        `json:"location"`
	StartTime            pgtype.Timestamptz `json:"start_time"`
	EndTime              pgtype.Timestamptz `json:"end_time"`
	AllDay               pgtype.Bool        `json:"all_day"`
	Status               pgtype.Text        `json:"status"`
	UserResponse         pgtype.Text        `json:"user_response"`
	OrganizerEmail       pgtype.Text        `json:"organizer_email"`
	Attendees            []byte             `json:"attendees"`
	MatchedContactIds    []pgtype.UUID      `json:"matched_contact_ids"`
	SyncedAt             pgtype.Timestamptz `json:"synced_at"`
	LastContactedUpdated pgtype.Bool        `json:"last_contacted_updated"`
}

// Insert or update a calendar event from Google Calendar
func (q *Queries) UpsertCalendarEvent(ctx context.Context, arg UpsertCalendarEventParams) (*CalendarEvent, error) {
	row := q.db.QueryRow(ctx, UpsertCalendarEvent,
		arg.GcalEventID,
		arg.GcalCalendarID,
		arg.GoogleAccountID,
		arg.Title,
		arg.Description,
		arg.Location,
		arg.StartTime,
		arg.EndTime,
		arg.AllDay,
		arg.Status,
		arg.UserResponse,
		arg.OrganizerEmail,
		arg.Attendees,
		arg.MatchedContactIds,
		arg.SyncedAt,
		arg.LastContactedUpdated,
	)
	var i CalendarEvent
	err := row.Scan(
		&i.ID,
		&i.GcalEventID,
		&i.GcalCalendarID,
		&i.GoogleAccountID,
		&i.Title,
		&i.Description,
		&i.Location,
		&i.StartTime,
		&i.EndTime,
		&i.AllDay,
		&i.Status,
		&i.UserResponse,
		&i.OrganizerEmail,
		&i.Attendees,
		&i.MatchedContactIds,
		&i.SyncedAt,
		&i.LastContactedUpdated,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
