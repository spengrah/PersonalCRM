// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: external_sync.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CompleteSyncLog = `-- name: CompleteSyncLog :one
UPDATE external_sync_log
SET completed_at = NOW(),
    status = $2,
    items_processed = $3,
    items_matched = $4,
    items_created = $5,
    error_message = $6
WHERE id = $1
RETURNING id, sync_state_id, source, account_id, started_at, completed_at, status, items_processed, items_matched, items_created, error_message, metadata, created_at
`

type CompleteSyncLogParams struct {
	ID             pgtype.UUID `json:"id"`
	Status         string      `json:"status"`
	ItemsProcessed pgtype.Int4 `json:"items_processed"`
	ItemsMatched   pgtype.Int4 `json:"items_matched"`
	ItemsCreated   pgtype.Int4 `json:"items_created"`
	ErrorMessage   pgtype.Text `json:"error_message"`
}

func (q *Queries) CompleteSyncLog(ctx context.Context, arg CompleteSyncLogParams) (*ExternalSyncLog, error) {
	row := q.db.QueryRow(ctx, CompleteSyncLog,
		arg.ID,
		arg.Status,
		arg.ItemsProcessed,
		arg.ItemsMatched,
		arg.ItemsCreated,
		arg.ErrorMessage,
	)
	var i ExternalSyncLog
	err := row.Scan(
		&i.ID,
		&i.SyncStateID,
		&i.Source,
		&i.AccountID,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Status,
		&i.ItemsProcessed,
		&i.ItemsMatched,
		&i.ItemsCreated,
		&i.ErrorMessage,
		&i.Metadata,
		&i.CreatedAt,
	)
	return &i, err
}

const CountSyncLogsByState = `-- name: CountSyncLogsByState :one
SELECT COUNT(*) FROM external_sync_log
WHERE sync_state_id = $1
`

func (q *Queries) CountSyncLogsByState(ctx context.Context, syncStateID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountSyncLogsByState, syncStateID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateSyncLog = `-- name: CreateSyncLog :one

INSERT INTO external_sync_log (
    sync_state_id,
    source,
    account_id,
    status,
    metadata
) VALUES (
    $1,
    $2,
    $3,
    'running',
    COALESCE($4::jsonb, '{}'::jsonb)
) RETURNING id, sync_state_id, source, account_id, started_at, completed_at, status, items_processed, items_matched, items_created, error_message, metadata, created_at
`

type CreateSyncLogParams struct {
	SyncStateID pgtype.UUID `json:"sync_state_id"`
	Source      string      `json:"source"`
	AccountID   pgtype.Text `json:"account_id"`
	Metadata    []byte      `json:"metadata"`
}

// External Sync Log Queries
func (q *Queries) CreateSyncLog(ctx context.Context, arg CreateSyncLogParams) (*ExternalSyncLog, error) {
	row := q.db.QueryRow(ctx, CreateSyncLog,
		arg.SyncStateID,
		arg.Source,
		arg.AccountID,
		arg.Metadata,
	)
	var i ExternalSyncLog
	err := row.Scan(
		&i.ID,
		&i.SyncStateID,
		&i.Source,
		&i.AccountID,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Status,
		&i.ItemsProcessed,
		&i.ItemsMatched,
		&i.ItemsCreated,
		&i.ErrorMessage,
		&i.Metadata,
		&i.CreatedAt,
	)
	return &i, err
}

const CreateSyncState = `-- name: CreateSyncState :one
INSERT INTO external_sync_state (
    source,
    account_id,
    enabled,
    status,
    strategy,
    next_sync_at,
    metadata
) VALUES (
    $1,
    $2,
    $3,
    COALESCE($4, 'idle'),
    COALESCE($5, 'contact_driven'),
    $6,
    COALESCE($7::jsonb, '{}'::jsonb)
) RETURNING id, source, account_id, enabled, status, strategy, last_sync_at, last_successful_sync_at, next_sync_at, sync_cursor, error_message, error_count, metadata, created_at, updated_at
`

type CreateSyncStateParams struct {
	Source     string             `json:"source"`
	AccountID  pgtype.Text        `json:"account_id"`
	Enabled    bool               `json:"enabled"`
	Status     interface{}        `json:"status"`
	Strategy   interface{}        `json:"strategy"`
	NextSyncAt pgtype.Timestamptz `json:"next_sync_at"`
	Metadata   []byte             `json:"metadata"`
}

func (q *Queries) CreateSyncState(ctx context.Context, arg CreateSyncStateParams) (*ExternalSyncState, error) {
	row := q.db.QueryRow(ctx, CreateSyncState,
		arg.Source,
		arg.AccountID,
		arg.Enabled,
		arg.Status,
		arg.Strategy,
		arg.NextSyncAt,
		arg.Metadata,
	)
	var i ExternalSyncState
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.AccountID,
		&i.Enabled,
		&i.Status,
		&i.Strategy,
		&i.LastSyncAt,
		&i.LastSuccessfulSyncAt,
		&i.NextSyncAt,
		&i.SyncCursor,
		&i.ErrorMessage,
		&i.ErrorCount,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeleteOldSyncLogs = `-- name: DeleteOldSyncLogs :exec
DELETE FROM external_sync_log
WHERE created_at < $1
`

func (q *Queries) DeleteOldSyncLogs(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, DeleteOldSyncLogs, createdAt)
	return err
}

const DeleteSyncState = `-- name: DeleteSyncState :exec
DELETE FROM external_sync_state
WHERE id = $1
`

func (q *Queries) DeleteSyncState(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeleteSyncState, id)
	return err
}

const DeleteSyncStatesByAccountID = `-- name: DeleteSyncStatesByAccountID :exec
DELETE FROM external_sync_state
WHERE account_id IS NOT NULL AND account_id = $1
`

func (q *Queries) DeleteSyncStatesByAccountID(ctx context.Context, accountID pgtype.Text) error {
	_, err := q.db.Exec(ctx, DeleteSyncStatesByAccountID, accountID)
	return err
}

const GetSyncLog = `-- name: GetSyncLog :one
SELECT id, sync_state_id, source, account_id, started_at, completed_at, status, items_processed, items_matched, items_created, error_message, metadata, created_at FROM external_sync_log
WHERE id = $1
`

func (q *Queries) GetSyncLog(ctx context.Context, id pgtype.UUID) (*ExternalSyncLog, error) {
	row := q.db.QueryRow(ctx, GetSyncLog, id)
	var i ExternalSyncLog
	err := row.Scan(
		&i.ID,
		&i.SyncStateID,
		&i.Source,
		&i.AccountID,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Status,
		&i.ItemsProcessed,
		&i.ItemsMatched,
		&i.ItemsCreated,
		&i.ErrorMessage,
		&i.Metadata,
		&i.CreatedAt,
	)
	return &i, err
}

const GetSyncState = `-- name: GetSyncState :one

SELECT id, source, account_id, enabled, status, strategy, last_sync_at, last_successful_sync_at, next_sync_at, sync_cursor, error_message, error_count, metadata, created_at, updated_at FROM external_sync_state
WHERE id = $1
`

// External Sync State Queries
func (q *Queries) GetSyncState(ctx context.Context, id pgtype.UUID) (*ExternalSyncState, error) {
	row := q.db.QueryRow(ctx, GetSyncState, id)
	var i ExternalSyncState
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.AccountID,
		&i.Enabled,
		&i.Status,
		&i.Strategy,
		&i.LastSyncAt,
		&i.LastSuccessfulSyncAt,
		&i.NextSyncAt,
		&i.SyncCursor,
		&i.ErrorMessage,
		&i.ErrorCount,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetSyncStateBySource = `-- name: GetSyncStateBySource :one
SELECT id, source, account_id, enabled, status, strategy, last_sync_at, last_successful_sync_at, next_sync_at, sync_cursor, error_message, error_count, metadata, created_at, updated_at FROM external_sync_state
WHERE source = $1 AND COALESCE(account_id, '') = COALESCE($2, '')
`

type GetSyncStateBySourceParams struct {
	Source    string      `json:"source"`
	AccountID pgtype.Text `json:"account_id"`
}

func (q *Queries) GetSyncStateBySource(ctx context.Context, arg GetSyncStateBySourceParams) (*ExternalSyncState, error) {
	row := q.db.QueryRow(ctx, GetSyncStateBySource, arg.Source, arg.AccountID)
	var i ExternalSyncState
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.AccountID,
		&i.Enabled,
		&i.Status,
		&i.Strategy,
		&i.LastSyncAt,
		&i.LastSuccessfulSyncAt,
		&i.NextSyncAt,
		&i.SyncCursor,
		&i.ErrorMessage,
		&i.ErrorCount,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListDueSyncStates = `-- name: ListDueSyncStates :many
SELECT id, source, account_id, enabled, status, strategy, last_sync_at, last_successful_sync_at, next_sync_at, sync_cursor, error_message, error_count, metadata, created_at, updated_at FROM external_sync_state
WHERE enabled = TRUE
  AND status NOT IN ('syncing', 'disabled')
  AND (next_sync_at IS NULL OR next_sync_at <= $1)
ORDER BY next_sync_at ASC NULLS FIRST
`

func (q *Queries) ListDueSyncStates(ctx context.Context, nextSyncAt pgtype.Timestamptz) ([]*ExternalSyncState, error) {
	rows, err := q.db.Query(ctx, ListDueSyncStates, nextSyncAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ExternalSyncState{}
	for rows.Next() {
		var i ExternalSyncState
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.AccountID,
			&i.Enabled,
			&i.Status,
			&i.Strategy,
			&i.LastSyncAt,
			&i.LastSuccessfulSyncAt,
			&i.NextSyncAt,
			&i.SyncCursor,
			&i.ErrorMessage,
			&i.ErrorCount,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListEnabledSyncStates = `-- name: ListEnabledSyncStates :many
SELECT id, source, account_id, enabled, status, strategy, last_sync_at, last_successful_sync_at, next_sync_at, sync_cursor, error_message, error_count, metadata, created_at, updated_at FROM external_sync_state
WHERE enabled = TRUE AND status != 'disabled'
ORDER BY source, account_id
`

func (q *Queries) ListEnabledSyncStates(ctx context.Context) ([]*ExternalSyncState, error) {
	rows, err := q.db.Query(ctx, ListEnabledSyncStates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ExternalSyncState{}
	for rows.Next() {
		var i ExternalSyncState
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.AccountID,
			&i.Enabled,
			&i.Status,
			&i.Strategy,
			&i.LastSyncAt,
			&i.LastSuccessfulSyncAt,
			&i.NextSyncAt,
			&i.SyncCursor,
			&i.ErrorMessage,
			&i.ErrorCount,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListRecentSyncLogs = `-- name: ListRecentSyncLogs :many
SELECT id, sync_state_id, source, account_id, started_at, completed_at, status, items_processed, items_matched, items_created, error_message, metadata, created_at FROM external_sync_log
ORDER BY started_at DESC
LIMIT $1
`

func (q *Queries) ListRecentSyncLogs(ctx context.Context, limit int32) ([]*ExternalSyncLog, error) {
	rows, err := q.db.Query(ctx, ListRecentSyncLogs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ExternalSyncLog{}
	for rows.Next() {
		var i ExternalSyncLog
		if err := rows.Scan(
			&i.ID,
			&i.SyncStateID,
			&i.Source,
			&i.AccountID,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Status,
			&i.ItemsProcessed,
			&i.ItemsMatched,
			&i.ItemsCreated,
			&i.ErrorMessage,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSyncLogsByState = `-- name: ListSyncLogsByState :many
SELECT id, sync_state_id, source, account_id, started_at, completed_at, status, items_processed, items_matched, items_created, error_message, metadata, created_at FROM external_sync_log
WHERE sync_state_id = $1
ORDER BY started_at DESC
LIMIT $2 OFFSET $3
`

type ListSyncLogsByStateParams struct {
	SyncStateID pgtype.UUID `json:"sync_state_id"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
}

func (q *Queries) ListSyncLogsByState(ctx context.Context, arg ListSyncLogsByStateParams) ([]*ExternalSyncLog, error) {
	rows, err := q.db.Query(ctx, ListSyncLogsByState, arg.SyncStateID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ExternalSyncLog{}
	for rows.Next() {
		var i ExternalSyncLog
		if err := rows.Scan(
			&i.ID,
			&i.SyncStateID,
			&i.Source,
			&i.AccountID,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Status,
			&i.ItemsProcessed,
			&i.ItemsMatched,
			&i.ItemsCreated,
			&i.ErrorMessage,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSyncStates = `-- name: ListSyncStates :many
SELECT id, source, account_id, enabled, status, strategy, last_sync_at, last_successful_sync_at, next_sync_at, sync_cursor, error_message, error_count, metadata, created_at, updated_at FROM external_sync_state
ORDER BY source, account_id
`

func (q *Queries) ListSyncStates(ctx context.Context) ([]*ExternalSyncState, error) {
	rows, err := q.db.Query(ctx, ListSyncStates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ExternalSyncState{}
	for rows.Next() {
		var i ExternalSyncState
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.AccountID,
			&i.Enabled,
			&i.Status,
			&i.Strategy,
			&i.LastSyncAt,
			&i.LastSuccessfulSyncAt,
			&i.NextSyncAt,
			&i.SyncCursor,
			&i.ErrorMessage,
			&i.ErrorCount,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateSyncStateCursor = `-- name: UpdateSyncStateCursor :exec
UPDATE external_sync_state
SET sync_cursor = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateSyncStateCursorParams struct {
	ID         pgtype.UUID `json:"id"`
	SyncCursor pgtype.Text `json:"sync_cursor"`
}

func (q *Queries) UpdateSyncStateCursor(ctx context.Context, arg UpdateSyncStateCursorParams) error {
	_, err := q.db.Exec(ctx, UpdateSyncStateCursor, arg.ID, arg.SyncCursor)
	return err
}

const UpdateSyncStateEnabled = `-- name: UpdateSyncStateEnabled :one
UPDATE external_sync_state
SET enabled = $2,
    status = CASE WHEN $2 = FALSE THEN 'disabled' ELSE 'idle' END,
    updated_at = NOW()
WHERE id = $1
RETURNING id, source, account_id, enabled, status, strategy, last_sync_at, last_successful_sync_at, next_sync_at, sync_cursor, error_message, error_count, metadata, created_at, updated_at
`

type UpdateSyncStateEnabledParams struct {
	ID      pgtype.UUID `json:"id"`
	Enabled bool        `json:"enabled"`
}

func (q *Queries) UpdateSyncStateEnabled(ctx context.Context, arg UpdateSyncStateEnabledParams) (*ExternalSyncState, error) {
	row := q.db.QueryRow(ctx, UpdateSyncStateEnabled, arg.ID, arg.Enabled)
	var i ExternalSyncState
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.AccountID,
		&i.Enabled,
		&i.Status,
		&i.Strategy,
		&i.LastSyncAt,
		&i.LastSuccessfulSyncAt,
		&i.NextSyncAt,
		&i.SyncCursor,
		&i.ErrorMessage,
		&i.ErrorCount,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateSyncStateMetadata = `-- name: UpdateSyncStateMetadata :one
UPDATE external_sync_state
SET metadata = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, source, account_id, enabled, status, strategy, last_sync_at, last_successful_sync_at, next_sync_at, sync_cursor, error_message, error_count, metadata, created_at, updated_at
`

type UpdateSyncStateMetadataParams struct {
	ID       pgtype.UUID `json:"id"`
	Metadata []byte      `json:"metadata"`
}

func (q *Queries) UpdateSyncStateMetadata(ctx context.Context, arg UpdateSyncStateMetadataParams) (*ExternalSyncState, error) {
	row := q.db.QueryRow(ctx, UpdateSyncStateMetadata, arg.ID, arg.Metadata)
	var i ExternalSyncState
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.AccountID,
		&i.Enabled,
		&i.Status,
		&i.Strategy,
		&i.LastSyncAt,
		&i.LastSuccessfulSyncAt,
		&i.NextSyncAt,
		&i.SyncCursor,
		&i.ErrorMessage,
		&i.ErrorCount,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateSyncStateNextSync = `-- name: UpdateSyncStateNextSync :exec
UPDATE external_sync_state
SET next_sync_at = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateSyncStateNextSyncParams struct {
	ID         pgtype.UUID        `json:"id"`
	NextSyncAt pgtype.Timestamptz `json:"next_sync_at"`
}

func (q *Queries) UpdateSyncStateNextSync(ctx context.Context, arg UpdateSyncStateNextSyncParams) error {
	_, err := q.db.Exec(ctx, UpdateSyncStateNextSync, arg.ID, arg.NextSyncAt)
	return err
}

const UpdateSyncStateStatus = `-- name: UpdateSyncStateStatus :one
UPDATE external_sync_state
SET status = $2,
    error_message = CASE WHEN $2 = 'error' THEN $3 ELSE NULL END,
    error_count = CASE WHEN $2 = 'error' THEN error_count + 1 ELSE 0 END,
    last_sync_at = NOW(),
    updated_at = NOW()
WHERE id = $1
RETURNING id, source, account_id, enabled, status, strategy, last_sync_at, last_successful_sync_at, next_sync_at, sync_cursor, error_message, error_count, metadata, created_at, updated_at
`

type UpdateSyncStateStatusParams struct {
	ID           pgtype.UUID `json:"id"`
	Status       string      `json:"status"`
	ErrorMessage pgtype.Text `json:"error_message"`
}

func (q *Queries) UpdateSyncStateStatus(ctx context.Context, arg UpdateSyncStateStatusParams) (*ExternalSyncState, error) {
	row := q.db.QueryRow(ctx, UpdateSyncStateStatus, arg.ID, arg.Status, arg.ErrorMessage)
	var i ExternalSyncState
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.AccountID,
		&i.Enabled,
		&i.Status,
		&i.Strategy,
		&i.LastSyncAt,
		&i.LastSuccessfulSyncAt,
		&i.NextSyncAt,
		&i.SyncCursor,
		&i.ErrorMessage,
		&i.ErrorCount,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateSyncStateSuccess = `-- name: UpdateSyncStateSuccess :one
UPDATE external_sync_state
SET status = 'idle',
    last_sync_at = NOW(),
    last_successful_sync_at = NOW(),
    next_sync_at = $2,
    sync_cursor = $3,
    error_message = NULL,
    error_count = 0,
    updated_at = NOW()
WHERE id = $1
RETURNING id, source, account_id, enabled, status, strategy, last_sync_at, last_successful_sync_at, next_sync_at, sync_cursor, error_message, error_count, metadata, created_at, updated_at
`

type UpdateSyncStateSuccessParams struct {
	ID         pgtype.UUID        `json:"id"`
	NextSyncAt pgtype.Timestamptz `json:"next_sync_at"`
	SyncCursor pgtype.Text        `json:"sync_cursor"`
}

func (q *Queries) UpdateSyncStateSuccess(ctx context.Context, arg UpdateSyncStateSuccessParams) (*ExternalSyncState, error) {
	row := q.db.QueryRow(ctx, UpdateSyncStateSuccess, arg.ID, arg.NextSyncAt, arg.SyncCursor)
	var i ExternalSyncState
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.AccountID,
		&i.Enabled,
		&i.Status,
		&i.Strategy,
		&i.LastSyncAt,
		&i.LastSuccessfulSyncAt,
		&i.NextSyncAt,
		&i.SyncCursor,
		&i.ErrorMessage,
		&i.ErrorCount,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
