// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: note.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountContactNotes = `-- name: CountContactNotes :one
SELECT COUNT(*) FROM note WHERE contact_id = $1
`

func (q *Queries) CountContactNotes(ctx context.Context, contactID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountContactNotes, contactID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateNote = `-- name: CreateNote :one
INSERT INTO note (contact_id, body, category) 
VALUES ($1, $2, $3) 
RETURNING id, contact_id, body, category, created_at, updated_at
`

type CreateNoteParams struct {
	ContactID pgtype.UUID `json:"contact_id"`
	Body      string      `json:"body"`
	Category  pgtype.Text `json:"category"`
}

func (q *Queries) CreateNote(ctx context.Context, arg CreateNoteParams) (*Note, error) {
	row := q.db.QueryRow(ctx, CreateNote, arg.ContactID, arg.Body, arg.Category)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.Body,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeleteNote = `-- name: DeleteNote :exec
DELETE FROM note WHERE id = $1
`

func (q *Queries) DeleteNote(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeleteNote, id)
	return err
}

const GetNote = `-- name: GetNote :one

SELECT id, contact_id, body, category, created_at, updated_at FROM note WHERE id = $1
`

// Note queries
func (q *Queries) GetNote(ctx context.Context, id pgtype.UUID) (*Note, error) {
	row := q.db.QueryRow(ctx, GetNote, id)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.Body,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListContactNotes = `-- name: ListContactNotes :many
SELECT id, contact_id, body, category, created_at, updated_at FROM note 
WHERE contact_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListContactNotesParams struct {
	ContactID pgtype.UUID `json:"contact_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListContactNotes(ctx context.Context, arg ListContactNotesParams) ([]*Note, error) {
	rows, err := q.db.Query(ctx, ListContactNotes, arg.ContactID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Note{}
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.Body,
			&i.Category,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchNotes = `-- name: SearchNotes :many
SELECT id, contact_id, body, category, created_at, updated_at FROM note 
WHERE body ILIKE '%' || $1 || '%'
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchNotesParams struct {
	Column1 pgtype.Text `json:"column_1"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

func (q *Queries) SearchNotes(ctx context.Context, arg SearchNotesParams) ([]*Note, error) {
	rows, err := q.db.Query(ctx, SearchNotes, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Note{}
	for rows.Next() {
		var i Note
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.Body,
			&i.Category,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateNote = `-- name: UpdateNote :one
UPDATE note SET
  body = $2,
  category = $3,
  updated_at = NOW()
WHERE id = $1
RETURNING id, contact_id, body, category, created_at, updated_at
`

type UpdateNoteParams struct {
	ID       pgtype.UUID `json:"id"`
	Body     string      `json:"body"`
	Category pgtype.Text `json:"category"`
}

func (q *Queries) UpdateNote(ctx context.Context, arg UpdateNoteParams) (*Note, error) {
	row := q.db.QueryRow(ctx, UpdateNote, arg.ID, arg.Body, arg.Category)
	var i Note
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.Body,
		&i.Category,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
