// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: external_contact.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountAllUnmatchedExternalContacts = `-- name: CountAllUnmatchedExternalContacts :one
SELECT COUNT(*) FROM external_contact
WHERE match_status = 'unmatched'
  AND duplicate_of_id IS NULL
`

func (q *Queries) CountAllUnmatchedExternalContacts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountAllUnmatchedExternalContacts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountUnmatchedExternalContacts = `-- name: CountUnmatchedExternalContacts :one
SELECT COUNT(*) FROM external_contact
WHERE source = $1
  AND match_status = 'unmatched'
  AND duplicate_of_id IS NULL
`

func (q *Queries) CountUnmatchedExternalContacts(ctx context.Context, source string) (int64, error) {
	row := q.db.QueryRow(ctx, CountUnmatchedExternalContacts, source)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateEnrichment = `-- name: CreateEnrichment :one
INSERT INTO contact_enrichment (
    contact_id, source, account_id, field, external_contact_id, original_value
) VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (contact_id, source, field, COALESCE(account_id, '')) DO UPDATE SET
    external_contact_id = EXCLUDED.external_contact_id,
    original_value = EXCLUDED.original_value,
    enriched_at = NOW()
RETURNING id, contact_id, source, account_id, field, external_contact_id, original_value, enriched_at
`

type CreateEnrichmentParams struct {
	ContactID         pgtype.UUID `json:"contact_id"`
	Source            string      `json:"source"`
	AccountID         pgtype.Text `json:"account_id"`
	Field             string      `json:"field"`
	ExternalContactID pgtype.UUID `json:"external_contact_id"`
	OriginalValue     pgtype.Text `json:"original_value"`
}

func (q *Queries) CreateEnrichment(ctx context.Context, arg CreateEnrichmentParams) (*ContactEnrichment, error) {
	row := q.db.QueryRow(ctx, CreateEnrichment,
		arg.ContactID,
		arg.Source,
		arg.AccountID,
		arg.Field,
		arg.ExternalContactID,
		arg.OriginalValue,
	)
	var i ContactEnrichment
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.Source,
		&i.AccountID,
		&i.Field,
		&i.ExternalContactID,
		&i.OriginalValue,
		&i.EnrichedAt,
	)
	return &i, err
}

const DeleteEnrichment = `-- name: DeleteEnrichment :exec
DELETE FROM contact_enrichment WHERE id = $1
`

func (q *Queries) DeleteEnrichment(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeleteEnrichment, id)
	return err
}

const DeleteEnrichmentsForContact = `-- name: DeleteEnrichmentsForContact :exec
DELETE FROM contact_enrichment WHERE contact_id = $1
`

func (q *Queries) DeleteEnrichmentsForContact(ctx context.Context, contactID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeleteEnrichmentsForContact, contactID)
	return err
}

const DeleteExternalContact = `-- name: DeleteExternalContact :exec
DELETE FROM external_contact WHERE id = $1
`

func (q *Queries) DeleteExternalContact(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeleteExternalContact, id)
	return err
}

const DeleteExternalContactsBySourceAccount = `-- name: DeleteExternalContactsBySourceAccount :exec
DELETE FROM external_contact
WHERE source = $1 AND COALESCE(account_id, '') = COALESCE($2, '')
`

type DeleteExternalContactsBySourceAccountParams struct {
	Source    string      `json:"source"`
	AccountID pgtype.Text `json:"account_id"`
}

func (q *Queries) DeleteExternalContactsBySourceAccount(ctx context.Context, arg DeleteExternalContactsBySourceAccountParams) error {
	_, err := q.db.Exec(ctx, DeleteExternalContactsBySourceAccount, arg.Source, arg.AccountID)
	return err
}

const FindExternalContactsByEmail = `-- name: FindExternalContactsByEmail :many
SELECT id, source, source_id, account_id, display_name, first_name, last_name, emails, phones, addresses, organization, job_title, birthday, photo_url, crm_contact_id, match_status, duplicate_of_id, etag, metadata, synced_at, created_at, updated_at FROM external_contact
WHERE emails @> $1::jsonb
  AND duplicate_of_id IS NULL
ORDER BY created_at
`

func (q *Queries) FindExternalContactsByEmail(ctx context.Context, dollar_1 []byte) ([]*ExternalContact, error) {
	rows, err := q.db.Query(ctx, FindExternalContactsByEmail, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ExternalContact{}
	for rows.Next() {
		var i ExternalContact
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.SourceID,
			&i.AccountID,
			&i.DisplayName,
			&i.FirstName,
			&i.LastName,
			&i.Emails,
			&i.Phones,
			&i.Addresses,
			&i.Organization,
			&i.JobTitle,
			&i.Birthday,
			&i.PhotoUrl,
			&i.CrmContactID,
			&i.MatchStatus,
			&i.DuplicateOfID,
			&i.Etag,
			&i.Metadata,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const FindExternalContactsByNormalizedEmail = `-- name: FindExternalContactsByNormalizedEmail :many
SELECT id, source, source_id, account_id, display_name, first_name, last_name, emails, phones, addresses, organization, job_title, birthday, photo_url, crm_contact_id, match_status, duplicate_of_id, etag, metadata, synced_at, created_at, updated_at FROM external_contact
WHERE EXISTS (
    SELECT 1 FROM jsonb_array_elements(emails) AS e
    WHERE LOWER(e->>'value') = LOWER($1)
)
AND duplicate_of_id IS NULL
ORDER BY created_at
`

func (q *Queries) FindExternalContactsByNormalizedEmail(ctx context.Context, lower string) ([]*ExternalContact, error) {
	rows, err := q.db.Query(ctx, FindExternalContactsByNormalizedEmail, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ExternalContact{}
	for rows.Next() {
		var i ExternalContact
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.SourceID,
			&i.AccountID,
			&i.DisplayName,
			&i.FirstName,
			&i.LastName,
			&i.Emails,
			&i.Phones,
			&i.Addresses,
			&i.Organization,
			&i.JobTitle,
			&i.Birthday,
			&i.PhotoUrl,
			&i.CrmContactID,
			&i.MatchStatus,
			&i.DuplicateOfID,
			&i.Etag,
			&i.Metadata,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetEnrichmentByField = `-- name: GetEnrichmentByField :one
SELECT id, contact_id, source, account_id, field, external_contact_id, original_value, enriched_at FROM contact_enrichment
WHERE contact_id = $1 AND field = $2
LIMIT 1
`

type GetEnrichmentByFieldParams struct {
	ContactID pgtype.UUID `json:"contact_id"`
	Field     string      `json:"field"`
}

func (q *Queries) GetEnrichmentByField(ctx context.Context, arg GetEnrichmentByFieldParams) (*ContactEnrichment, error) {
	row := q.db.QueryRow(ctx, GetEnrichmentByField, arg.ContactID, arg.Field)
	var i ContactEnrichment
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.Source,
		&i.AccountID,
		&i.Field,
		&i.ExternalContactID,
		&i.OriginalValue,
		&i.EnrichedAt,
	)
	return &i, err
}

const GetEnrichmentsForContact = `-- name: GetEnrichmentsForContact :many

SELECT id, contact_id, source, account_id, field, external_contact_id, original_value, enriched_at FROM contact_enrichment
WHERE contact_id = $1
ORDER BY enriched_at DESC
`

// Contact Enrichment queries
func (q *Queries) GetEnrichmentsForContact(ctx context.Context, contactID pgtype.UUID) ([]*ContactEnrichment, error) {
	rows, err := q.db.Query(ctx, GetEnrichmentsForContact, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ContactEnrichment{}
	for rows.Next() {
		var i ContactEnrichment
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.Source,
			&i.AccountID,
			&i.Field,
			&i.ExternalContactID,
			&i.OriginalValue,
			&i.EnrichedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetExternalContact = `-- name: GetExternalContact :one

SELECT id, source, source_id, account_id, display_name, first_name, last_name, emails, phones, addresses, organization, job_title, birthday, photo_url, crm_contact_id, match_status, duplicate_of_id, etag, metadata, synced_at, created_at, updated_at FROM external_contact WHERE id = $1
`

// External Contact queries
func (q *Queries) GetExternalContact(ctx context.Context, id pgtype.UUID) (*ExternalContact, error) {
	row := q.db.QueryRow(ctx, GetExternalContact, id)
	var i ExternalContact
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.SourceID,
		&i.AccountID,
		&i.DisplayName,
		&i.FirstName,
		&i.LastName,
		&i.Emails,
		&i.Phones,
		&i.Addresses,
		&i.Organization,
		&i.JobTitle,
		&i.Birthday,
		&i.PhotoUrl,
		&i.CrmContactID,
		&i.MatchStatus,
		&i.DuplicateOfID,
		&i.Etag,
		&i.Metadata,
		&i.SyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetExternalContactBySource = `-- name: GetExternalContactBySource :one
SELECT id, source, source_id, account_id, display_name, first_name, last_name, emails, phones, addresses, organization, job_title, birthday, photo_url, crm_contact_id, match_status, duplicate_of_id, etag, metadata, synced_at, created_at, updated_at FROM external_contact
WHERE source = $1 AND source_id = $2 AND COALESCE(account_id, '') = COALESCE($3, '')
`

type GetExternalContactBySourceParams struct {
	Source    string      `json:"source"`
	SourceID  string      `json:"source_id"`
	AccountID pgtype.Text `json:"account_id"`
}

func (q *Queries) GetExternalContactBySource(ctx context.Context, arg GetExternalContactBySourceParams) (*ExternalContact, error) {
	row := q.db.QueryRow(ctx, GetExternalContactBySource, arg.Source, arg.SourceID, arg.AccountID)
	var i ExternalContact
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.SourceID,
		&i.AccountID,
		&i.DisplayName,
		&i.FirstName,
		&i.LastName,
		&i.Emails,
		&i.Phones,
		&i.Addresses,
		&i.Organization,
		&i.JobTitle,
		&i.Birthday,
		&i.PhotoUrl,
		&i.CrmContactID,
		&i.MatchStatus,
		&i.DuplicateOfID,
		&i.Etag,
		&i.Metadata,
		&i.SyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const HasEnrichmentForField = `-- name: HasEnrichmentForField :one
SELECT EXISTS(
    SELECT 1 FROM contact_enrichment
    WHERE contact_id = $1 AND field = $2
)
`

type HasEnrichmentForFieldParams struct {
	ContactID pgtype.UUID `json:"contact_id"`
	Field     string      `json:"field"`
}

func (q *Queries) HasEnrichmentForField(ctx context.Context, arg HasEnrichmentForFieldParams) (bool, error) {
	row := q.db.QueryRow(ctx, HasEnrichmentForField, arg.ContactID, arg.Field)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const IgnoreExternalContact = `-- name: IgnoreExternalContact :exec
UPDATE external_contact SET
    match_status = 'ignored',
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) IgnoreExternalContact(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, IgnoreExternalContact, id)
	return err
}

const ListAllUnmatchedExternalContacts = `-- name: ListAllUnmatchedExternalContacts :many
SELECT id, source, source_id, account_id, display_name, first_name, last_name, emails, phones, addresses, organization, job_title, birthday, photo_url, crm_contact_id, match_status, duplicate_of_id, etag, metadata, synced_at, created_at, updated_at FROM external_contact
WHERE match_status = 'unmatched'
  AND duplicate_of_id IS NULL
ORDER BY source, display_name
LIMIT $1 OFFSET $2
`

type ListAllUnmatchedExternalContactsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAllUnmatchedExternalContacts(ctx context.Context, arg ListAllUnmatchedExternalContactsParams) ([]*ExternalContact, error) {
	rows, err := q.db.Query(ctx, ListAllUnmatchedExternalContacts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ExternalContact{}
	for rows.Next() {
		var i ExternalContact
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.SourceID,
			&i.AccountID,
			&i.DisplayName,
			&i.FirstName,
			&i.LastName,
			&i.Emails,
			&i.Phones,
			&i.Addresses,
			&i.Organization,
			&i.JobTitle,
			&i.Birthday,
			&i.PhotoUrl,
			&i.CrmContactID,
			&i.MatchStatus,
			&i.DuplicateOfID,
			&i.Etag,
			&i.Metadata,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListEnrichmentsBySource = `-- name: ListEnrichmentsBySource :many
SELECT id, contact_id, source, account_id, field, external_contact_id, original_value, enriched_at FROM contact_enrichment
WHERE source = $1
ORDER BY enriched_at DESC
LIMIT $2 OFFSET $3
`

type ListEnrichmentsBySourceParams struct {
	Source string `json:"source"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListEnrichmentsBySource(ctx context.Context, arg ListEnrichmentsBySourceParams) ([]*ContactEnrichment, error) {
	rows, err := q.db.Query(ctx, ListEnrichmentsBySource, arg.Source, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ContactEnrichment{}
	for rows.Next() {
		var i ContactEnrichment
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.Source,
			&i.AccountID,
			&i.Field,
			&i.ExternalContactID,
			&i.OriginalValue,
			&i.EnrichedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListExternalContactsBySource = `-- name: ListExternalContactsBySource :many
SELECT id, source, source_id, account_id, display_name, first_name, last_name, emails, phones, addresses, organization, job_title, birthday, photo_url, crm_contact_id, match_status, duplicate_of_id, etag, metadata, synced_at, created_at, updated_at FROM external_contact
WHERE source = $1 AND ($2::text IS NULL OR account_id = $2)
ORDER BY display_name
LIMIT $3 OFFSET $4
`

type ListExternalContactsBySourceParams struct {
	Source  string `json:"source"`
	Column2 string `json:"column_2"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) ListExternalContactsBySource(ctx context.Context, arg ListExternalContactsBySourceParams) ([]*ExternalContact, error) {
	rows, err := q.db.Query(ctx, ListExternalContactsBySource,
		arg.Source,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ExternalContact{}
	for rows.Next() {
		var i ExternalContact
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.SourceID,
			&i.AccountID,
			&i.DisplayName,
			&i.FirstName,
			&i.LastName,
			&i.Emails,
			&i.Phones,
			&i.Addresses,
			&i.Organization,
			&i.JobTitle,
			&i.Birthday,
			&i.PhotoUrl,
			&i.CrmContactID,
			&i.MatchStatus,
			&i.DuplicateOfID,
			&i.Etag,
			&i.Metadata,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListExternalContactsForCRMContact = `-- name: ListExternalContactsForCRMContact :many
SELECT id, source, source_id, account_id, display_name, first_name, last_name, emails, phones, addresses, organization, job_title, birthday, photo_url, crm_contact_id, match_status, duplicate_of_id, etag, metadata, synced_at, created_at, updated_at FROM external_contact
WHERE crm_contact_id = $1
ORDER BY source, account_id
`

func (q *Queries) ListExternalContactsForCRMContact(ctx context.Context, crmContactID pgtype.UUID) ([]*ExternalContact, error) {
	rows, err := q.db.Query(ctx, ListExternalContactsForCRMContact, crmContactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ExternalContact{}
	for rows.Next() {
		var i ExternalContact
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.SourceID,
			&i.AccountID,
			&i.DisplayName,
			&i.FirstName,
			&i.LastName,
			&i.Emails,
			&i.Phones,
			&i.Addresses,
			&i.Organization,
			&i.JobTitle,
			&i.Birthday,
			&i.PhotoUrl,
			&i.CrmContactID,
			&i.MatchStatus,
			&i.DuplicateOfID,
			&i.Etag,
			&i.Metadata,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListUnmatchedExternalContacts = `-- name: ListUnmatchedExternalContacts :many
SELECT id, source, source_id, account_id, display_name, first_name, last_name, emails, phones, addresses, organization, job_title, birthday, photo_url, crm_contact_id, match_status, duplicate_of_id, etag, metadata, synced_at, created_at, updated_at FROM external_contact
WHERE source = $1
  AND match_status = 'unmatched'
  AND duplicate_of_id IS NULL
ORDER BY display_name
LIMIT $2 OFFSET $3
`

type ListUnmatchedExternalContactsParams struct {
	Source string `json:"source"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListUnmatchedExternalContacts(ctx context.Context, arg ListUnmatchedExternalContactsParams) ([]*ExternalContact, error) {
	rows, err := q.db.Query(ctx, ListUnmatchedExternalContacts, arg.Source, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ExternalContact{}
	for rows.Next() {
		var i ExternalContact
		if err := rows.Scan(
			&i.ID,
			&i.Source,
			&i.SourceID,
			&i.AccountID,
			&i.DisplayName,
			&i.FirstName,
			&i.LastName,
			&i.Emails,
			&i.Phones,
			&i.Addresses,
			&i.Organization,
			&i.JobTitle,
			&i.Birthday,
			&i.PhotoUrl,
			&i.CrmContactID,
			&i.MatchStatus,
			&i.DuplicateOfID,
			&i.Etag,
			&i.Metadata,
			&i.SyncedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateExternalContactDuplicate = `-- name: UpdateExternalContactDuplicate :exec
UPDATE external_contact SET
    duplicate_of_id = $2,
    updated_at = NOW()
WHERE id = $1
`

type UpdateExternalContactDuplicateParams struct {
	ID            pgtype.UUID `json:"id"`
	DuplicateOfID pgtype.UUID `json:"duplicate_of_id"`
}

func (q *Queries) UpdateExternalContactDuplicate(ctx context.Context, arg UpdateExternalContactDuplicateParams) error {
	_, err := q.db.Exec(ctx, UpdateExternalContactDuplicate, arg.ID, arg.DuplicateOfID)
	return err
}

const UpdateExternalContactMatch = `-- name: UpdateExternalContactMatch :one
UPDATE external_contact SET
    crm_contact_id = $2,
    match_status = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, source, source_id, account_id, display_name, first_name, last_name, emails, phones, addresses, organization, job_title, birthday, photo_url, crm_contact_id, match_status, duplicate_of_id, etag, metadata, synced_at, created_at, updated_at
`

type UpdateExternalContactMatchParams struct {
	ID           pgtype.UUID `json:"id"`
	CrmContactID pgtype.UUID `json:"crm_contact_id"`
	MatchStatus  pgtype.Text `json:"match_status"`
}

func (q *Queries) UpdateExternalContactMatch(ctx context.Context, arg UpdateExternalContactMatchParams) (*ExternalContact, error) {
	row := q.db.QueryRow(ctx, UpdateExternalContactMatch, arg.ID, arg.CrmContactID, arg.MatchStatus)
	var i ExternalContact
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.SourceID,
		&i.AccountID,
		&i.DisplayName,
		&i.FirstName,
		&i.LastName,
		&i.Emails,
		&i.Phones,
		&i.Addresses,
		&i.Organization,
		&i.JobTitle,
		&i.Birthday,
		&i.PhotoUrl,
		&i.CrmContactID,
		&i.MatchStatus,
		&i.DuplicateOfID,
		&i.Etag,
		&i.Metadata,
		&i.SyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpsertExternalContact = `-- name: UpsertExternalContact :one
INSERT INTO external_contact (
    source, source_id, account_id, display_name, first_name, last_name,
    emails, phones, addresses, organization, job_title, birthday, photo_url,
    crm_contact_id, match_status, duplicate_of_id, etag, metadata, synced_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
ON CONFLICT (source, source_id, COALESCE(account_id, '')) DO UPDATE SET
    display_name = EXCLUDED.display_name,
    first_name = EXCLUDED.first_name,
    last_name = EXCLUDED.last_name,
    emails = EXCLUDED.emails,
    phones = EXCLUDED.phones,
    addresses = EXCLUDED.addresses,
    organization = EXCLUDED.organization,
    job_title = EXCLUDED.job_title,
    birthday = EXCLUDED.birthday,
    photo_url = EXCLUDED.photo_url,
    etag = EXCLUDED.etag,
    metadata = EXCLUDED.metadata,
    synced_at = EXCLUDED.synced_at,
    updated_at = NOW()
RETURNING id, source, source_id, account_id, display_name, first_name, last_name, emails, phones, addresses, organization, job_title, birthday, photo_url, crm_contact_id, match_status, duplicate_of_id, etag, metadata, synced_at, created_at, updated_at
`

type UpsertExternalContactParams struct {
	Source        string             `json:"source"`
	SourceID      string             `json:"source_id"`
	AccountID     pgtype.Text        `json:"account_id"`
	DisplayName   pgtype.Text        `json:"display_name"`
	FirstName     pgtype.Text        `json:"first_name"`
	LastName      pgtype.Text        `json:"last_name"`
	Emails        []byte             `json:"emails"`
	Phones        []byte             `json:"phones"`
	Addresses     []byte             `json:"addresses"`
	Organization  pgtype.Text        `json:"organization"`
	JobTitle      pgtype.Text        `json:"job_title"`
	Birthday      pgtype.Date        `json:"birthday"`
	PhotoUrl      pgtype.Text        `json:"photo_url"`
	CrmContactID  pgtype.UUID        `json:"crm_contact_id"`
	MatchStatus   pgtype.Text        `json:"match_status"`
	DuplicateOfID pgtype.UUID        `json:"duplicate_of_id"`
	Etag          pgtype.Text        `json:"etag"`
	Metadata      []byte             `json:"metadata"`
	SyncedAt      pgtype.Timestamptz `json:"synced_at"`
}

func (q *Queries) UpsertExternalContact(ctx context.Context, arg UpsertExternalContactParams) (*ExternalContact, error) {
	row := q.db.QueryRow(ctx, UpsertExternalContact,
		arg.Source,
		arg.SourceID,
		arg.AccountID,
		arg.DisplayName,
		arg.FirstName,
		arg.LastName,
		arg.Emails,
		arg.Phones,
		arg.Addresses,
		arg.Organization,
		arg.JobTitle,
		arg.Birthday,
		arg.PhotoUrl,
		arg.CrmContactID,
		arg.MatchStatus,
		arg.DuplicateOfID,
		arg.Etag,
		arg.Metadata,
		arg.SyncedAt,
	)
	var i ExternalContact
	err := row.Scan(
		&i.ID,
		&i.Source,
		&i.SourceID,
		&i.AccountID,
		&i.DisplayName,
		&i.FirstName,
		&i.LastName,
		&i.Emails,
		&i.Phones,
		&i.Addresses,
		&i.Organization,
		&i.JobTitle,
		&i.Birthday,
		&i.PhotoUrl,
		&i.CrmContactID,
		&i.MatchStatus,
		&i.DuplicateOfID,
		&i.Etag,
		&i.Metadata,
		&i.SyncedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
