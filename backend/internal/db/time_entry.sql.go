// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: time_entry.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateTimeEntry = `-- name: CreateTimeEntry :one
INSERT INTO time_entry (
    description,
    project,
    contact_id,
    start_time,
    end_time,
    duration_minutes
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, description, project, contact_id, start_time, end_time, duration_minutes, created_at, updated_at
`

type CreateTimeEntryParams struct {
	Description     string             `json:"description"`
	Project         pgtype.Text        `json:"project"`
	ContactID       pgtype.UUID        `json:"contact_id"`
	StartTime       pgtype.Timestamptz `json:"start_time"`
	EndTime         pgtype.Timestamptz `json:"end_time"`
	DurationMinutes pgtype.Int4        `json:"duration_minutes"`
}

func (q *Queries) CreateTimeEntry(ctx context.Context, arg CreateTimeEntryParams) (*TimeEntry, error) {
	row := q.db.QueryRow(ctx, CreateTimeEntry,
		arg.Description,
		arg.Project,
		arg.ContactID,
		arg.StartTime,
		arg.EndTime,
		arg.DurationMinutes,
	)
	var i TimeEntry
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Project,
		&i.ContactID,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMinutes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const DeleteTimeEntry = `-- name: DeleteTimeEntry :exec
DELETE FROM time_entry
WHERE id = $1
`

func (q *Queries) DeleteTimeEntry(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeleteTimeEntry, id)
	return err
}

const GetRunningTimeEntry = `-- name: GetRunningTimeEntry :one
SELECT id, description, project, contact_id, start_time, end_time, duration_minutes, created_at, updated_at FROM time_entry
WHERE end_time IS NULL
ORDER BY start_time DESC
LIMIT 1
`

func (q *Queries) GetRunningTimeEntry(ctx context.Context) (*TimeEntry, error) {
	row := q.db.QueryRow(ctx, GetRunningTimeEntry)
	var i TimeEntry
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Project,
		&i.ContactID,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMinutes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetTimeEntry = `-- name: GetTimeEntry :one
SELECT id, description, project, contact_id, start_time, end_time, duration_minutes, created_at, updated_at FROM time_entry
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTimeEntry(ctx context.Context, id pgtype.UUID) (*TimeEntry, error) {
	row := q.db.QueryRow(ctx, GetTimeEntry, id)
	var i TimeEntry
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Project,
		&i.ContactID,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMinutes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetTimeEntryStats = `-- name: GetTimeEntryStats :one
SELECT
    COUNT(*) as total_entries,
    COALESCE(SUM(duration_minutes), 0) as total_minutes,
    COALESCE(SUM(CASE WHEN DATE(start_time) = CURRENT_DATE THEN duration_minutes ELSE 0 END), 0) as today_minutes,
    COALESCE(SUM(CASE WHEN DATE(start_time) >= DATE_TRUNC('week', CURRENT_DATE) THEN duration_minutes ELSE 0 END), 0) as week_minutes,
    COALESCE(SUM(CASE WHEN DATE(start_time) >= DATE_TRUNC('month', CURRENT_DATE) THEN duration_minutes ELSE 0 END), 0) as month_minutes
FROM time_entry
WHERE end_time IS NOT NULL
`

type GetTimeEntryStatsRow struct {
	TotalEntries int64       `json:"total_entries"`
	TotalMinutes interface{} `json:"total_minutes"`
	TodayMinutes interface{} `json:"today_minutes"`
	WeekMinutes  interface{} `json:"week_minutes"`
	MonthMinutes interface{} `json:"month_minutes"`
}

func (q *Queries) GetTimeEntryStats(ctx context.Context) (*GetTimeEntryStatsRow, error) {
	row := q.db.QueryRow(ctx, GetTimeEntryStats)
	var i GetTimeEntryStatsRow
	err := row.Scan(
		&i.TotalEntries,
		&i.TotalMinutes,
		&i.TodayMinutes,
		&i.WeekMinutes,
		&i.MonthMinutes,
	)
	return &i, err
}

const ListTimeEntries = `-- name: ListTimeEntries :many
SELECT id, description, project, contact_id, start_time, end_time, duration_minutes, created_at, updated_at FROM time_entry
ORDER BY start_time DESC
LIMIT $1 OFFSET $2
`

type ListTimeEntriesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListTimeEntries(ctx context.Context, arg ListTimeEntriesParams) ([]*TimeEntry, error) {
	rows, err := q.db.Query(ctx, ListTimeEntries, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TimeEntry{}
	for rows.Next() {
		var i TimeEntry
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Project,
			&i.ContactID,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMinutes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListTimeEntriesByContact = `-- name: ListTimeEntriesByContact :many
SELECT id, description, project, contact_id, start_time, end_time, duration_minutes, created_at, updated_at FROM time_entry
WHERE contact_id = $1
ORDER BY start_time DESC
`

func (q *Queries) ListTimeEntriesByContact(ctx context.Context, contactID pgtype.UUID) ([]*TimeEntry, error) {
	rows, err := q.db.Query(ctx, ListTimeEntriesByContact, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TimeEntry{}
	for rows.Next() {
		var i TimeEntry
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Project,
			&i.ContactID,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMinutes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListTimeEntriesByDateRange = `-- name: ListTimeEntriesByDateRange :many
SELECT id, description, project, contact_id, start_time, end_time, duration_minutes, created_at, updated_at FROM time_entry
WHERE start_time >= $1 AND start_time <= $2
ORDER BY start_time DESC
`

type ListTimeEntriesByDateRangeParams struct {
	StartTime   pgtype.Timestamptz `json:"start_time"`
	StartTime_2 pgtype.Timestamptz `json:"start_time_2"`
}

func (q *Queries) ListTimeEntriesByDateRange(ctx context.Context, arg ListTimeEntriesByDateRangeParams) ([]*TimeEntry, error) {
	rows, err := q.db.Query(ctx, ListTimeEntriesByDateRange, arg.StartTime, arg.StartTime_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*TimeEntry{}
	for rows.Next() {
		var i TimeEntry
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Project,
			&i.ContactID,
			&i.StartTime,
			&i.EndTime,
			&i.DurationMinutes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateTimeEntry = `-- name: UpdateTimeEntry :one
UPDATE time_entry
SET
    description = COALESCE($2, description),
    project = COALESCE($3, project),
    contact_id = COALESCE($4, contact_id),
    end_time = COALESCE($5, end_time),
    duration_minutes = COALESCE($6, duration_minutes),
    updated_at = NOW()
WHERE id = $1
RETURNING id, description, project, contact_id, start_time, end_time, duration_minutes, created_at, updated_at
`

type UpdateTimeEntryParams struct {
	ID              pgtype.UUID        `json:"id"`
	Description     string             `json:"description"`
	Project         pgtype.Text        `json:"project"`
	ContactID       pgtype.UUID        `json:"contact_id"`
	EndTime         pgtype.Timestamptz `json:"end_time"`
	DurationMinutes pgtype.Int4        `json:"duration_minutes"`
}

func (q *Queries) UpdateTimeEntry(ctx context.Context, arg UpdateTimeEntryParams) (*TimeEntry, error) {
	row := q.db.QueryRow(ctx, UpdateTimeEntry,
		arg.ID,
		arg.Description,
		arg.Project,
		arg.ContactID,
		arg.EndTime,
		arg.DurationMinutes,
	)
	var i TimeEntry
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.Project,
		&i.ContactID,
		&i.StartTime,
		&i.EndTime,
		&i.DurationMinutes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
