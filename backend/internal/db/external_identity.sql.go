// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: external_identity.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const BulkLinkIdentitiesToContact = `-- name: BulkLinkIdentitiesToContact :exec
UPDATE external_identity SET
    contact_id = $2,
    match_type = $3,
    match_confidence = $4,
    updated_at = NOW()
WHERE id = ANY($1::uuid[])
`

type BulkLinkIdentitiesToContactParams struct {
	Column1         []pgtype.UUID `json:"column_1"`
	ContactID       pgtype.UUID   `json:"contact_id"`
	MatchType       pgtype.Text   `json:"match_type"`
	MatchConfidence pgtype.Float8 `json:"match_confidence"`
}

func (q *Queries) BulkLinkIdentitiesToContact(ctx context.Context, arg BulkLinkIdentitiesToContactParams) error {
	_, err := q.db.Exec(ctx, BulkLinkIdentitiesToContact,
		arg.Column1,
		arg.ContactID,
		arg.MatchType,
		arg.MatchConfidence,
	)
	return err
}

const CountIdentitiesBySource = `-- name: CountIdentitiesBySource :one
SELECT COUNT(*) FROM external_identity WHERE source = $1
`

func (q *Queries) CountIdentitiesBySource(ctx context.Context, source string) (int64, error) {
	row := q.db.QueryRow(ctx, CountIdentitiesBySource, source)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountUnmatchedIdentities = `-- name: CountUnmatchedIdentities :one
SELECT COUNT(*) FROM external_identity WHERE contact_id IS NULL
`

func (q *Queries) CountUnmatchedIdentities(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountUnmatchedIdentities)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const DeleteIdentitiesForContact = `-- name: DeleteIdentitiesForContact :exec
DELETE FROM external_identity WHERE contact_id = $1
`

func (q *Queries) DeleteIdentitiesForContact(ctx context.Context, contactID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeleteIdentitiesForContact, contactID)
	return err
}

const DeleteIdentity = `-- name: DeleteIdentity :exec
DELETE FROM external_identity WHERE id = $1
`

func (q *Queries) DeleteIdentity(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeleteIdentity, id)
	return err
}

const FindIdentitiesByIdentifier = `-- name: FindIdentitiesByIdentifier :many
SELECT id, identifier, identifier_type, raw_identifier, source, source_id, contact_id, match_type, match_confidence, display_name, last_seen_at, message_count, created_at, updated_at FROM external_identity
WHERE identifier_type = $1 AND identifier = $2
`

type FindIdentitiesByIdentifierParams struct {
	IdentifierType string `json:"identifier_type"`
	Identifier     string `json:"identifier"`
}

func (q *Queries) FindIdentitiesByIdentifier(ctx context.Context, arg FindIdentitiesByIdentifierParams) ([]*ExternalIdentity, error) {
	rows, err := q.db.Query(ctx, FindIdentitiesByIdentifier, arg.IdentifierType, arg.Identifier)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ExternalIdentity{}
	for rows.Next() {
		var i ExternalIdentity
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.IdentifierType,
			&i.RawIdentifier,
			&i.Source,
			&i.SourceID,
			&i.ContactID,
			&i.MatchType,
			&i.MatchConfidence,
			&i.DisplayName,
			&i.LastSeenAt,
			&i.MessageCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetIdentityByID = `-- name: GetIdentityByID :one

SELECT id, identifier, identifier_type, raw_identifier, source, source_id, contact_id, match_type, match_confidence, display_name, last_seen_at, message_count, created_at, updated_at FROM external_identity
WHERE id = $1
`

// External identity queries for cross-platform contact identity matching
func (q *Queries) GetIdentityByID(ctx context.Context, id pgtype.UUID) (*ExternalIdentity, error) {
	row := q.db.QueryRow(ctx, GetIdentityByID, id)
	var i ExternalIdentity
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.IdentifierType,
		&i.RawIdentifier,
		&i.Source,
		&i.SourceID,
		&i.ContactID,
		&i.MatchType,
		&i.MatchConfidence,
		&i.DisplayName,
		&i.LastSeenAt,
		&i.MessageCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetIdentityByIdentifier = `-- name: GetIdentityByIdentifier :one
SELECT id, identifier, identifier_type, raw_identifier, source, source_id, contact_id, match_type, match_confidence, display_name, last_seen_at, message_count, created_at, updated_at FROM external_identity
WHERE identifier_type = $1 AND identifier = $2 AND source = $3
`

type GetIdentityByIdentifierParams struct {
	IdentifierType string `json:"identifier_type"`
	Identifier     string `json:"identifier"`
	Source         string `json:"source"`
}

func (q *Queries) GetIdentityByIdentifier(ctx context.Context, arg GetIdentityByIdentifierParams) (*ExternalIdentity, error) {
	row := q.db.QueryRow(ctx, GetIdentityByIdentifier, arg.IdentifierType, arg.Identifier, arg.Source)
	var i ExternalIdentity
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.IdentifierType,
		&i.RawIdentifier,
		&i.Source,
		&i.SourceID,
		&i.ContactID,
		&i.MatchType,
		&i.MatchConfidence,
		&i.DisplayName,
		&i.LastSeenAt,
		&i.MessageCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const LinkIdentityToContact = `-- name: LinkIdentityToContact :one
UPDATE external_identity SET
    contact_id = $2,
    match_type = $3,
    match_confidence = $4,
    updated_at = NOW()
WHERE id = $1
RETURNING id, identifier, identifier_type, raw_identifier, source, source_id, contact_id, match_type, match_confidence, display_name, last_seen_at, message_count, created_at, updated_at
`

type LinkIdentityToContactParams struct {
	ID              pgtype.UUID   `json:"id"`
	ContactID       pgtype.UUID   `json:"contact_id"`
	MatchType       pgtype.Text   `json:"match_type"`
	MatchConfidence pgtype.Float8 `json:"match_confidence"`
}

func (q *Queries) LinkIdentityToContact(ctx context.Context, arg LinkIdentityToContactParams) (*ExternalIdentity, error) {
	row := q.db.QueryRow(ctx, LinkIdentityToContact,
		arg.ID,
		arg.ContactID,
		arg.MatchType,
		arg.MatchConfidence,
	)
	var i ExternalIdentity
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.IdentifierType,
		&i.RawIdentifier,
		&i.Source,
		&i.SourceID,
		&i.ContactID,
		&i.MatchType,
		&i.MatchConfidence,
		&i.DisplayName,
		&i.LastSeenAt,
		&i.MessageCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListIdentitiesBySource = `-- name: ListIdentitiesBySource :many
SELECT id, identifier, identifier_type, raw_identifier, source, source_id, contact_id, match_type, match_confidence, display_name, last_seen_at, message_count, created_at, updated_at FROM external_identity
WHERE source = $1
ORDER BY last_seen_at DESC NULLS LAST
LIMIT $2 OFFSET $3
`

type ListIdentitiesBySourceParams struct {
	Source string `json:"source"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListIdentitiesBySource(ctx context.Context, arg ListIdentitiesBySourceParams) ([]*ExternalIdentity, error) {
	rows, err := q.db.Query(ctx, ListIdentitiesBySource, arg.Source, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ExternalIdentity{}
	for rows.Next() {
		var i ExternalIdentity
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.IdentifierType,
			&i.RawIdentifier,
			&i.Source,
			&i.SourceID,
			&i.ContactID,
			&i.MatchType,
			&i.MatchConfidence,
			&i.DisplayName,
			&i.LastSeenAt,
			&i.MessageCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListIdentitiesForContact = `-- name: ListIdentitiesForContact :many
SELECT id, identifier, identifier_type, raw_identifier, source, source_id, contact_id, match_type, match_confidence, display_name, last_seen_at, message_count, created_at, updated_at FROM external_identity
WHERE contact_id = $1
ORDER BY source, identifier_type
`

func (q *Queries) ListIdentitiesForContact(ctx context.Context, contactID pgtype.UUID) ([]*ExternalIdentity, error) {
	rows, err := q.db.Query(ctx, ListIdentitiesForContact, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ExternalIdentity{}
	for rows.Next() {
		var i ExternalIdentity
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.IdentifierType,
			&i.RawIdentifier,
			&i.Source,
			&i.SourceID,
			&i.ContactID,
			&i.MatchType,
			&i.MatchConfidence,
			&i.DisplayName,
			&i.LastSeenAt,
			&i.MessageCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListUnmatchedIdentities = `-- name: ListUnmatchedIdentities :many
SELECT id, identifier, identifier_type, raw_identifier, source, source_id, contact_id, match_type, match_confidence, display_name, last_seen_at, message_count, created_at, updated_at FROM external_identity
WHERE contact_id IS NULL
ORDER BY message_count DESC, last_seen_at DESC NULLS LAST
LIMIT $1 OFFSET $2
`

type ListUnmatchedIdentitiesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUnmatchedIdentities(ctx context.Context, arg ListUnmatchedIdentitiesParams) ([]*ExternalIdentity, error) {
	rows, err := q.db.Query(ctx, ListUnmatchedIdentities, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ExternalIdentity{}
	for rows.Next() {
		var i ExternalIdentity
		if err := rows.Scan(
			&i.ID,
			&i.Identifier,
			&i.IdentifierType,
			&i.RawIdentifier,
			&i.Source,
			&i.SourceID,
			&i.ContactID,
			&i.MatchType,
			&i.MatchConfidence,
			&i.DisplayName,
			&i.LastSeenAt,
			&i.MessageCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UnlinkIdentityFromContact = `-- name: UnlinkIdentityFromContact :one
UPDATE external_identity SET
    contact_id = NULL,
    match_type = 'unmatched',
    match_confidence = NULL,
    updated_at = NOW()
WHERE id = $1
RETURNING id, identifier, identifier_type, raw_identifier, source, source_id, contact_id, match_type, match_confidence, display_name, last_seen_at, message_count, created_at, updated_at
`

func (q *Queries) UnlinkIdentityFromContact(ctx context.Context, id pgtype.UUID) (*ExternalIdentity, error) {
	row := q.db.QueryRow(ctx, UnlinkIdentityFromContact, id)
	var i ExternalIdentity
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.IdentifierType,
		&i.RawIdentifier,
		&i.Source,
		&i.SourceID,
		&i.ContactID,
		&i.MatchType,
		&i.MatchConfidence,
		&i.DisplayName,
		&i.LastSeenAt,
		&i.MessageCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateIdentityMessageCount = `-- name: UpdateIdentityMessageCount :one
UPDATE external_identity SET
    message_count = message_count + $2,
    last_seen_at = $3,
    updated_at = NOW()
WHERE id = $1
RETURNING id, identifier, identifier_type, raw_identifier, source, source_id, contact_id, match_type, match_confidence, display_name, last_seen_at, message_count, created_at, updated_at
`

type UpdateIdentityMessageCountParams struct {
	ID           pgtype.UUID        `json:"id"`
	MessageCount pgtype.Int4        `json:"message_count"`
	LastSeenAt   pgtype.Timestamptz `json:"last_seen_at"`
}

func (q *Queries) UpdateIdentityMessageCount(ctx context.Context, arg UpdateIdentityMessageCountParams) (*ExternalIdentity, error) {
	row := q.db.QueryRow(ctx, UpdateIdentityMessageCount, arg.ID, arg.MessageCount, arg.LastSeenAt)
	var i ExternalIdentity
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.IdentifierType,
		&i.RawIdentifier,
		&i.Source,
		&i.SourceID,
		&i.ContactID,
		&i.MatchType,
		&i.MatchConfidence,
		&i.DisplayName,
		&i.LastSeenAt,
		&i.MessageCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpsertIdentity = `-- name: UpsertIdentity :one
INSERT INTO external_identity (
    identifier, identifier_type, raw_identifier, source, source_id,
    contact_id, match_type, match_confidence, display_name, last_seen_at, message_count
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
ON CONFLICT (identifier, identifier_type, source) DO UPDATE SET
    raw_identifier = COALESCE(EXCLUDED.raw_identifier, external_identity.raw_identifier),
    source_id = COALESCE(EXCLUDED.source_id, external_identity.source_id),
    contact_id = COALESCE(EXCLUDED.contact_id, external_identity.contact_id),
    match_type = COALESCE(EXCLUDED.match_type, external_identity.match_type),
    match_confidence = COALESCE(EXCLUDED.match_confidence, external_identity.match_confidence),
    display_name = COALESCE(EXCLUDED.display_name, external_identity.display_name),
    last_seen_at = EXCLUDED.last_seen_at,
    message_count = external_identity.message_count + COALESCE(EXCLUDED.message_count, 0),
    updated_at = NOW()
RETURNING id, identifier, identifier_type, raw_identifier, source, source_id, contact_id, match_type, match_confidence, display_name, last_seen_at, message_count, created_at, updated_at
`

type UpsertIdentityParams struct {
	Identifier      string             `json:"identifier"`
	IdentifierType  string             `json:"identifier_type"`
	RawIdentifier   pgtype.Text        `json:"raw_identifier"`
	Source          string             `json:"source"`
	SourceID        pgtype.Text        `json:"source_id"`
	ContactID       pgtype.UUID        `json:"contact_id"`
	MatchType       pgtype.Text        `json:"match_type"`
	MatchConfidence pgtype.Float8      `json:"match_confidence"`
	DisplayName     pgtype.Text        `json:"display_name"`
	LastSeenAt      pgtype.Timestamptz `json:"last_seen_at"`
	MessageCount    pgtype.Int4        `json:"message_count"`
}

func (q *Queries) UpsertIdentity(ctx context.Context, arg UpsertIdentityParams) (*ExternalIdentity, error) {
	row := q.db.QueryRow(ctx, UpsertIdentity,
		arg.Identifier,
		arg.IdentifierType,
		arg.RawIdentifier,
		arg.Source,
		arg.SourceID,
		arg.ContactID,
		arg.MatchType,
		arg.MatchConfidence,
		arg.DisplayName,
		arg.LastSeenAt,
		arg.MessageCount,
	)
	var i ExternalIdentity
	err := row.Scan(
		&i.ID,
		&i.Identifier,
		&i.IdentifierType,
		&i.RawIdentifier,
		&i.Source,
		&i.SourceID,
		&i.ContactID,
		&i.MatchType,
		&i.MatchConfidence,
		&i.DisplayName,
		&i.LastSeenAt,
		&i.MessageCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
