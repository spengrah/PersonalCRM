// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: oauth.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountOAuthCredentials = `-- name: CountOAuthCredentials :one
SELECT COUNT(*) FROM oauth_credential WHERE provider = $1
`

// Count OAuth credentials for a provider
func (q *Queries) CountOAuthCredentials(ctx context.Context, provider string) (int64, error) {
	row := q.db.QueryRow(ctx, CountOAuthCredentials, provider)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const DeleteOAuthCredential = `-- name: DeleteOAuthCredential :exec
DELETE FROM oauth_credential WHERE id = $1
`

// Delete an OAuth credential by ID
func (q *Queries) DeleteOAuthCredential(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, DeleteOAuthCredential, id)
	return err
}

const DeleteOAuthCredentialByProvider = `-- name: DeleteOAuthCredentialByProvider :exec
DELETE FROM oauth_credential WHERE provider = $1
`

// Delete all OAuth credentials for a provider
func (q *Queries) DeleteOAuthCredentialByProvider(ctx context.Context, provider string) error {
	_, err := q.db.Exec(ctx, DeleteOAuthCredentialByProvider, provider)
	return err
}

const GetOAuthCredential = `-- name: GetOAuthCredential :one

SELECT id, provider, account_id, account_name, access_token_encrypted, refresh_token_encrypted, encryption_nonce, token_type, expires_at, scopes, created_at, updated_at FROM oauth_credential
WHERE provider = $1 AND account_id = $2
`

type GetOAuthCredentialParams struct {
	Provider  string `json:"provider"`
	AccountID string `json:"account_id"`
}

// OAuth Credential Queries
// Get a specific OAuth credential by provider and account ID
func (q *Queries) GetOAuthCredential(ctx context.Context, arg GetOAuthCredentialParams) (*OauthCredential, error) {
	row := q.db.QueryRow(ctx, GetOAuthCredential, arg.Provider, arg.AccountID)
	var i OauthCredential
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.AccountID,
		&i.AccountName,
		&i.AccessTokenEncrypted,
		&i.RefreshTokenEncrypted,
		&i.EncryptionNonce,
		&i.TokenType,
		&i.ExpiresAt,
		&i.Scopes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetOAuthCredentialByID = `-- name: GetOAuthCredentialByID :one
SELECT id, provider, account_id, account_name, access_token_encrypted, refresh_token_encrypted, encryption_nonce, token_type, expires_at, scopes, created_at, updated_at FROM oauth_credential
WHERE id = $1
`

// Get a specific OAuth credential by UUID
func (q *Queries) GetOAuthCredentialByID(ctx context.Context, id pgtype.UUID) (*OauthCredential, error) {
	row := q.db.QueryRow(ctx, GetOAuthCredentialByID, id)
	var i OauthCredential
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.AccountID,
		&i.AccountName,
		&i.AccessTokenEncrypted,
		&i.RefreshTokenEncrypted,
		&i.EncryptionNonce,
		&i.TokenType,
		&i.ExpiresAt,
		&i.Scopes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetOAuthCredentialStatus = `-- name: GetOAuthCredentialStatus :one
SELECT
    id,
    provider,
    account_id,
    account_name,
    expires_at,
    scopes,
    created_at,
    updated_at
FROM oauth_credential
WHERE id = $1
`

type GetOAuthCredentialStatusRow struct {
	ID          pgtype.UUID        `json:"id"`
	Provider    string             `json:"provider"`
	AccountID   string             `json:"account_id"`
	AccountName pgtype.Text        `json:"account_name"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	Scopes      []string           `json:"scopes"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

// Get non-sensitive credential info for display
func (q *Queries) GetOAuthCredentialStatus(ctx context.Context, id pgtype.UUID) (*GetOAuthCredentialStatusRow, error) {
	row := q.db.QueryRow(ctx, GetOAuthCredentialStatus, id)
	var i GetOAuthCredentialStatusRow
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.AccountID,
		&i.AccountName,
		&i.ExpiresAt,
		&i.Scopes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const ListAllOAuthCredentials = `-- name: ListAllOAuthCredentials :many
SELECT id, provider, account_id, account_name, access_token_encrypted, refresh_token_encrypted, encryption_nonce, token_type, expires_at, scopes, created_at, updated_at FROM oauth_credential
ORDER BY provider, created_at DESC
`

// List all OAuth credentials
func (q *Queries) ListAllOAuthCredentials(ctx context.Context) ([]*OauthCredential, error) {
	rows, err := q.db.Query(ctx, ListAllOAuthCredentials)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*OauthCredential{}
	for rows.Next() {
		var i OauthCredential
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.AccountID,
			&i.AccountName,
			&i.AccessTokenEncrypted,
			&i.RefreshTokenEncrypted,
			&i.EncryptionNonce,
			&i.TokenType,
			&i.ExpiresAt,
			&i.Scopes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListOAuthCredentialStatuses = `-- name: ListOAuthCredentialStatuses :many
SELECT
    id,
    provider,
    account_id,
    account_name,
    expires_at,
    scopes,
    created_at,
    updated_at
FROM oauth_credential
WHERE provider = $1
ORDER BY created_at DESC
`

type ListOAuthCredentialStatusesRow struct {
	ID          pgtype.UUID        `json:"id"`
	Provider    string             `json:"provider"`
	AccountID   string             `json:"account_id"`
	AccountName pgtype.Text        `json:"account_name"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	Scopes      []string           `json:"scopes"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

// List non-sensitive credential info for all credentials of a provider
func (q *Queries) ListOAuthCredentialStatuses(ctx context.Context, provider string) ([]*ListOAuthCredentialStatusesRow, error) {
	rows, err := q.db.Query(ctx, ListOAuthCredentialStatuses, provider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListOAuthCredentialStatusesRow{}
	for rows.Next() {
		var i ListOAuthCredentialStatusesRow
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.AccountID,
			&i.AccountName,
			&i.ExpiresAt,
			&i.Scopes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListOAuthCredentials = `-- name: ListOAuthCredentials :many
SELECT id, provider, account_id, account_name, access_token_encrypted, refresh_token_encrypted, encryption_nonce, token_type, expires_at, scopes, created_at, updated_at FROM oauth_credential
WHERE provider = $1
ORDER BY created_at DESC
`

// List all OAuth credentials for a provider
func (q *Queries) ListOAuthCredentials(ctx context.Context, provider string) ([]*OauthCredential, error) {
	rows, err := q.db.Query(ctx, ListOAuthCredentials, provider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*OauthCredential{}
	for rows.Next() {
		var i OauthCredential
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.AccountID,
			&i.AccountName,
			&i.AccessTokenEncrypted,
			&i.RefreshTokenEncrypted,
			&i.EncryptionNonce,
			&i.TokenType,
			&i.ExpiresAt,
			&i.Scopes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateOAuthCredentialTokens = `-- name: UpdateOAuthCredentialTokens :one
UPDATE oauth_credential SET
    access_token_encrypted = $2,
    refresh_token_encrypted = COALESCE($3, refresh_token_encrypted),
    encryption_nonce = $4,
    expires_at = $5,
    updated_at = NOW()
WHERE id = $1
RETURNING id, provider, account_id, account_name, access_token_encrypted, refresh_token_encrypted, encryption_nonce, token_type, expires_at, scopes, created_at, updated_at
`

type UpdateOAuthCredentialTokensParams struct {
	ID                    pgtype.UUID        `json:"id"`
	AccessTokenEncrypted  []byte             `json:"access_token_encrypted"`
	RefreshTokenEncrypted []byte             `json:"refresh_token_encrypted"`
	EncryptionNonce       []byte             `json:"encryption_nonce"`
	ExpiresAt             pgtype.Timestamptz `json:"expires_at"`
}

// Update only the token data (for token refresh)
func (q *Queries) UpdateOAuthCredentialTokens(ctx context.Context, arg UpdateOAuthCredentialTokensParams) (*OauthCredential, error) {
	row := q.db.QueryRow(ctx, UpdateOAuthCredentialTokens,
		arg.ID,
		arg.AccessTokenEncrypted,
		arg.RefreshTokenEncrypted,
		arg.EncryptionNonce,
		arg.ExpiresAt,
	)
	var i OauthCredential
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.AccountID,
		&i.AccountName,
		&i.AccessTokenEncrypted,
		&i.RefreshTokenEncrypted,
		&i.EncryptionNonce,
		&i.TokenType,
		&i.ExpiresAt,
		&i.Scopes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpsertOAuthCredential = `-- name: UpsertOAuthCredential :one
INSERT INTO oauth_credential (
    provider,
    account_id,
    account_name,
    access_token_encrypted,
    refresh_token_encrypted,
    encryption_nonce,
    token_type,
    expires_at,
    scopes
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT (provider, account_id) DO UPDATE SET
    account_name = EXCLUDED.account_name,
    access_token_encrypted = EXCLUDED.access_token_encrypted,
    refresh_token_encrypted = COALESCE(EXCLUDED.refresh_token_encrypted, oauth_credential.refresh_token_encrypted),
    encryption_nonce = EXCLUDED.encryption_nonce,
    token_type = EXCLUDED.token_type,
    expires_at = EXCLUDED.expires_at,
    scopes = EXCLUDED.scopes,
    updated_at = NOW()
RETURNING id, provider, account_id, account_name, access_token_encrypted, refresh_token_encrypted, encryption_nonce, token_type, expires_at, scopes, created_at, updated_at
`

type UpsertOAuthCredentialParams struct {
	Provider              string             `json:"provider"`
	AccountID             string             `json:"account_id"`
	AccountName           pgtype.Text        `json:"account_name"`
	AccessTokenEncrypted  []byte             `json:"access_token_encrypted"`
	RefreshTokenEncrypted []byte             `json:"refresh_token_encrypted"`
	EncryptionNonce       []byte             `json:"encryption_nonce"`
	TokenType             pgtype.Text        `json:"token_type"`
	ExpiresAt             pgtype.Timestamptz `json:"expires_at"`
	Scopes                []string           `json:"scopes"`
}

// Insert or update an OAuth credential
func (q *Queries) UpsertOAuthCredential(ctx context.Context, arg UpsertOAuthCredentialParams) (*OauthCredential, error) {
	row := q.db.QueryRow(ctx, UpsertOAuthCredential,
		arg.Provider,
		arg.AccountID,
		arg.AccountName,
		arg.AccessTokenEncrypted,
		arg.RefreshTokenEncrypted,
		arg.EncryptionNonce,
		arg.TokenType,
		arg.ExpiresAt,
		arg.Scopes,
	)
	var i OauthCredential
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.AccountID,
		&i.AccountName,
		&i.AccessTokenEncrypted,
		&i.RefreshTokenEncrypted,
		&i.EncryptionNonce,
		&i.TokenType,
		&i.ExpiresAt,
		&i.Scopes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
