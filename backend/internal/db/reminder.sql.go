// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reminder.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CompleteAutoRemindersForContact = `-- name: CompleteAutoRemindersForContact :exec
UPDATE reminder
SET completed = TRUE, completed_at = NOW()
WHERE contact_id = $1
  AND source = 'auto'
  AND completed = FALSE
  AND deleted_at IS NULL
`

func (q *Queries) CompleteAutoRemindersForContact(ctx context.Context, contactID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, CompleteAutoRemindersForContact, contactID)
	return err
}

const CompleteReminder = `-- name: CompleteReminder :one
UPDATE reminder
SET completed = TRUE, completed_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, contact_id, title, description, due_date, completed, completed_at, created_at, deleted_at, source
`

func (q *Queries) CompleteReminder(ctx context.Context, id pgtype.UUID) (*Reminder, error) {
	row := q.db.QueryRow(ctx, CompleteReminder, id)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.Title,
		&i.Description,
		&i.DueDate,
		&i.Completed,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Source,
	)
	return &i, err
}

const CountDueReminders = `-- name: CountDueReminders :one
SELECT COUNT(*) FROM reminder
WHERE due_date <= $1
  AND completed = FALSE
  AND deleted_at IS NULL
`

func (q *Queries) CountDueReminders(ctx context.Context, dueDate pgtype.Timestamptz) (int64, error) {
	row := q.db.QueryRow(ctx, CountDueReminders, dueDate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountReminders = `-- name: CountReminders :one
SELECT COUNT(*) FROM reminder
WHERE deleted_at IS NULL
`

func (q *Queries) CountReminders(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountReminders)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateReminder = `-- name: CreateReminder :one
INSERT INTO reminder (
    contact_id,
    title,
    description,
    due_date,
    source
) VALUES (
    $1, $2, $3, $4, COALESCE($5, 'manual')
) RETURNING id, contact_id, title, description, due_date, completed, completed_at, created_at, deleted_at, source
`

type CreateReminderParams struct {
	ContactID   pgtype.UUID        `json:"contact_id"`
	Title       string             `json:"title"`
	Description pgtype.Text        `json:"description"`
	DueDate     pgtype.Timestamptz `json:"due_date"`
	Source      interface{}        `json:"source"`
}

func (q *Queries) CreateReminder(ctx context.Context, arg CreateReminderParams) (*Reminder, error) {
	row := q.db.QueryRow(ctx, CreateReminder,
		arg.ContactID,
		arg.Title,
		arg.Description,
		arg.DueDate,
		arg.Source,
	)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.Title,
		&i.Description,
		&i.DueDate,
		&i.Completed,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Source,
	)
	return &i, err
}

const GetReminder = `-- name: GetReminder :one
SELECT id, contact_id, title, description, due_date, completed, completed_at, created_at, deleted_at, source FROM reminder
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetReminder(ctx context.Context, id pgtype.UUID) (*Reminder, error) {
	row := q.db.QueryRow(ctx, GetReminder, id)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.Title,
		&i.Description,
		&i.DueDate,
		&i.Completed,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Source,
	)
	return &i, err
}

const HardDeleteReminder = `-- name: HardDeleteReminder :exec
DELETE FROM reminder
WHERE id = $1
`

func (q *Queries) HardDeleteReminder(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, HardDeleteReminder, id)
	return err
}

const ListDueReminders = `-- name: ListDueReminders :many
SELECT r.id, r.contact_id, r.title, r.description, r.due_date, r.completed, r.completed_at, r.created_at, r.deleted_at, r.source,
       c.full_name as contact_name,
       cm.type as contact_primary_method_type,
       cm.value as contact_primary_method_value
FROM reminder r
LEFT JOIN contact c ON r.contact_id = c.id
LEFT JOIN LATERAL (
    SELECT type, value
    FROM contact_method
    WHERE contact_id = c.id
    ORDER BY
        CASE WHEN is_primary THEN 0 ELSE 1 END,
        CASE type
            WHEN 'email_personal' THEN 1
            WHEN 'email_work' THEN 2
            WHEN 'phone' THEN 3
            WHEN 'telegram' THEN 4
            WHEN 'signal' THEN 5
            WHEN 'discord' THEN 6
            WHEN 'twitter' THEN 7
            ELSE 8
        END,
        created_at ASC
    LIMIT 1
) cm ON TRUE
WHERE r.due_date <= $1 
  AND r.completed = FALSE 
  AND r.deleted_at IS NULL
  AND (c.deleted_at IS NULL OR r.contact_id IS NULL)
ORDER BY r.due_date ASC
`

type ListDueRemindersRow struct {
	ID                        pgtype.UUID        `json:"id"`
	ContactID                 pgtype.UUID        `json:"contact_id"`
	Title                     string             `json:"title"`
	Description               pgtype.Text        `json:"description"`
	DueDate                   pgtype.Timestamptz `json:"due_date"`
	Completed                 pgtype.Bool        `json:"completed"`
	CompletedAt               pgtype.Timestamptz `json:"completed_at"`
	CreatedAt                 pgtype.Timestamptz `json:"created_at"`
	DeletedAt                 pgtype.Timestamptz `json:"deleted_at"`
	Source                    pgtype.Text        `json:"source"`
	ContactName               pgtype.Text        `json:"contact_name"`
	ContactPrimaryMethodType  string             `json:"contact_primary_method_type"`
	ContactPrimaryMethodValue string             `json:"contact_primary_method_value"`
}

func (q *Queries) ListDueReminders(ctx context.Context, dueDate pgtype.Timestamptz) ([]*ListDueRemindersRow, error) {
	rows, err := q.db.Query(ctx, ListDueReminders, dueDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListDueRemindersRow{}
	for rows.Next() {
		var i ListDueRemindersRow
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.Title,
			&i.Description,
			&i.DueDate,
			&i.Completed,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Source,
			&i.ContactName,
			&i.ContactPrimaryMethodType,
			&i.ContactPrimaryMethodValue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListReminders = `-- name: ListReminders :many
SELECT id, contact_id, title, description, due_date, completed, completed_at, created_at, deleted_at, source FROM reminder
WHERE deleted_at IS NULL
ORDER BY due_date ASC
LIMIT $1 OFFSET $2
`

type ListRemindersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListReminders(ctx context.Context, arg ListRemindersParams) ([]*Reminder, error) {
	rows, err := q.db.Query(ctx, ListReminders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.Title,
			&i.Description,
			&i.DueDate,
			&i.Completed,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListRemindersByContact = `-- name: ListRemindersByContact :many
SELECT id, contact_id, title, description, due_date, completed, completed_at, created_at, deleted_at, source FROM reminder
WHERE contact_id = $1 AND deleted_at IS NULL
ORDER BY due_date DESC
`

func (q *Queries) ListRemindersByContact(ctx context.Context, contactID pgtype.UUID) ([]*Reminder, error) {
	rows, err := q.db.Query(ctx, ListRemindersByContact, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Reminder{}
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.ContactID,
			&i.Title,
			&i.Description,
			&i.DueDate,
			&i.Completed,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SoftDeleteReminder = `-- name: SoftDeleteReminder :exec
UPDATE reminder
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) SoftDeleteReminder(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, SoftDeleteReminder, id)
	return err
}

const SoftDeleteRemindersForContact = `-- name: SoftDeleteRemindersForContact :exec
UPDATE reminder
SET deleted_at = NOW()
WHERE contact_id = $1
  AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteRemindersForContact(ctx context.Context, contactID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, SoftDeleteRemindersForContact, contactID)
	return err
}

const UpdateReminder = `-- name: UpdateReminder :one
UPDATE reminder
SET title = COALESCE($2, title),
    description = COALESCE($3, description),
    due_date = COALESCE($4, due_date)
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, contact_id, title, description, due_date, completed, completed_at, created_at, deleted_at, source
`

type UpdateReminderParams struct {
	ID          pgtype.UUID        `json:"id"`
	Title       string             `json:"title"`
	Description pgtype.Text        `json:"description"`
	DueDate     pgtype.Timestamptz `json:"due_date"`
}

func (q *Queries) UpdateReminder(ctx context.Context, arg UpdateReminderParams) (*Reminder, error) {
	row := q.db.QueryRow(ctx, UpdateReminder,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.DueDate,
	)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.ContactID,
		&i.Title,
		&i.Description,
		&i.DueDate,
		&i.Completed,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Source,
	)
	return &i, err
}
