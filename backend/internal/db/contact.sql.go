// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: contact.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountContacts = `-- name: CountContacts :one
SELECT COUNT(*) FROM contact WHERE deleted_at IS NULL
`

func (q *Queries) CountContacts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountContacts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountSearchContacts = `-- name: CountSearchContacts :one
SELECT COUNT(*) FROM contact c
LEFT JOIN (
  SELECT contact_id, string_agg(value, ' ') AS method_values
  FROM contact_method
  GROUP BY contact_id
) cm ON cm.contact_id = c.id
WHERE c.deleted_at IS NULL
  AND to_tsvector('english', c.full_name || ' ' || COALESCE(cm.method_values, '')) @@ plainto_tsquery('english', $1)
`

func (q *Queries) CountSearchContacts(ctx context.Context, plaintoTsquery string) (int64, error) {
	row := q.db.QueryRow(ctx, CountSearchContacts, plaintoTsquery)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateContact = `-- name: CreateContact :one
INSERT INTO contact (
  full_name, location, birthday, how_met, cadence, last_contacted, profile_photo, notes, created_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, full_name, location, birthday, how_met, cadence, last_contacted, profile_photo, deleted_at, created_at, updated_at, notes
`

type CreateContactParams struct {
	FullName      string             `json:"full_name"`
	Location      pgtype.Text        `json:"location"`
	Birthday      pgtype.Date        `json:"birthday"`
	HowMet        pgtype.Text        `json:"how_met"`
	Cadence       pgtype.Text        `json:"cadence"`
	LastContacted pgtype.Timestamptz `json:"last_contacted"`
	ProfilePhoto  pgtype.Text        `json:"profile_photo"`
	Notes         pgtype.Text        `json:"notes"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateContact(ctx context.Context, arg CreateContactParams) (*Contact, error) {
	row := q.db.QueryRow(ctx, CreateContact,
		arg.FullName,
		arg.Location,
		arg.Birthday,
		arg.HowMet,
		arg.Cadence,
		arg.LastContacted,
		arg.ProfilePhoto,
		arg.Notes,
		arg.CreatedAt,
	)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Location,
		&i.Birthday,
		&i.HowMet,
		&i.Cadence,
		&i.LastContacted,
		&i.ProfilePhoto,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Notes,
	)
	return &i, err
}

const FindSimilarContacts = `-- name: FindSimilarContacts :many
SELECT
  c.id,
  c.full_name,
  similarity(c.full_name, $1::text) as name_similarity,
  COALESCE(
    json_agg(
      json_build_object(
        'type', cm.type,
        'value', cm.value
      )
    ) FILTER (WHERE cm.id IS NOT NULL),
    '[]'
  )::jsonb as methods_json
FROM contact c
LEFT JOIN contact_method cm ON c.id = cm.contact_id
WHERE c.deleted_at IS NULL
  AND similarity(c.full_name, $1::text) > $2::real
GROUP BY c.id, c.full_name
ORDER BY similarity(c.full_name, $1::text) DESC
LIMIT $3
`

type FindSimilarContactsParams struct {
	SearchName  string  `json:"search_name"`
	Threshold   float32 `json:"threshold"`
	ResultLimit int32   `json:"result_limit"`
}

type FindSimilarContactsRow struct {
	ID             pgtype.UUID `json:"id"`
	FullName       string      `json:"full_name"`
	NameSimilarity float32     `json:"name_similarity"`
	MethodsJson    []byte      `json:"methods_json"`
}

func (q *Queries) FindSimilarContacts(ctx context.Context, arg FindSimilarContactsParams) ([]*FindSimilarContactsRow, error) {
	rows, err := q.db.Query(ctx, FindSimilarContacts, arg.SearchName, arg.Threshold, arg.ResultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*FindSimilarContactsRow{}
	for rows.Next() {
		var i FindSimilarContactsRow
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.NameSimilarity,
			&i.MethodsJson,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetContact = `-- name: GetContact :one

SELECT id, full_name, location, birthday, how_met, cadence, last_contacted, profile_photo, deleted_at, created_at, updated_at, notes FROM contact 
WHERE id = $1 AND deleted_at IS NULL
`

// Contact queries
func (q *Queries) GetContact(ctx context.Context, id pgtype.UUID) (*Contact, error) {
	row := q.db.QueryRow(ctx, GetContact, id)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Location,
		&i.Birthday,
		&i.HowMet,
		&i.Cadence,
		&i.LastContacted,
		&i.ProfilePhoto,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Notes,
	)
	return &i, err
}

const HardDeleteContact = `-- name: HardDeleteContact :exec
DELETE FROM contact WHERE id = $1
`

func (q *Queries) HardDeleteContact(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, HardDeleteContact, id)
	return err
}

const ListContacts = `-- name: ListContacts :many
SELECT id, full_name, location, birthday, how_met, cadence, last_contacted, profile_photo, deleted_at, created_at, updated_at, notes FROM contact 
WHERE deleted_at IS NULL
LIMIT $1 OFFSET $2
`

type ListContactsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListContacts(ctx context.Context, arg ListContactsParams) ([]*Contact, error) {
	rows, err := q.db.Query(ctx, ListContacts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Contact{}
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Location,
			&i.Birthday,
			&i.HowMet,
			&i.Cadence,
			&i.LastContacted,
			&i.ProfilePhoto,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListContactsSorted = `-- name: ListContactsSorted :many
SELECT id, full_name, location, birthday, how_met, cadence, last_contacted, profile_photo, deleted_at, created_at, updated_at, notes FROM contact
WHERE deleted_at IS NULL
ORDER BY
  CASE WHEN $1 = 'name' AND $2 = 'asc' THEN full_name END ASC,
  CASE WHEN $1 = 'name' AND $2 = 'desc' THEN full_name END DESC,
  CASE WHEN $1 = 'location' AND $2 = 'asc' THEN COALESCE(location, '') END ASC,
  CASE WHEN $1 = 'location' AND $2 = 'desc' THEN COALESCE(location, '') END DESC,
  CASE WHEN $1 = 'birthday' AND $2 = 'asc' THEN birthday END ASC NULLS LAST,
  CASE WHEN $1 = 'birthday' AND $2 = 'desc' THEN birthday END DESC NULLS FIRST,
  CASE WHEN $1 = 'last_contacted' AND $2 = 'asc' THEN last_contacted END ASC NULLS LAST,
  CASE WHEN $1 = 'last_contacted' AND $2 = 'desc' THEN last_contacted END DESC NULLS FIRST
LIMIT $4 OFFSET $3
`

type ListContactsSortedParams struct {
	SortField  interface{} `json:"sort_field"`
	SortOrder  interface{} `json:"sort_order"`
	PageOffset int32       `json:"page_offset"`
	PageLimit  int32       `json:"page_limit"`
}

func (q *Queries) ListContactsSorted(ctx context.Context, arg ListContactsSortedParams) ([]*Contact, error) {
	rows, err := q.db.Query(ctx, ListContactsSorted,
		arg.SortField,
		arg.SortOrder,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Contact{}
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Location,
			&i.Birthday,
			&i.HowMet,
			&i.Cadence,
			&i.LastContacted,
			&i.ProfilePhoto,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchContacts = `-- name: SearchContacts :many
SELECT c.id, c.full_name, c.location, c.birthday, c.how_met, c.cadence, c.last_contacted, c.profile_photo, c.deleted_at, c.created_at, c.updated_at, c.notes FROM contact c
LEFT JOIN (
  SELECT contact_id, string_agg(value, ' ') AS method_values
  FROM contact_method
  GROUP BY contact_id
) cm ON cm.contact_id = c.id
WHERE c.deleted_at IS NULL
  AND to_tsvector('english', c.full_name || ' ' || COALESCE(cm.method_values, '')) @@ plainto_tsquery('english', $1)
ORDER BY ts_rank(
  to_tsvector('english', c.full_name || ' ' || COALESCE(cm.method_values, '')),
  plainto_tsquery('english', $1)
) DESC
LIMIT $2 OFFSET $3
`

type SearchContactsParams struct {
	PlaintoTsquery string `json:"plainto_tsquery"`
	Limit          int32  `json:"limit"`
	Offset         int32  `json:"offset"`
}

func (q *Queries) SearchContacts(ctx context.Context, arg SearchContactsParams) ([]*Contact, error) {
	rows, err := q.db.Query(ctx, SearchContacts, arg.PlaintoTsquery, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Contact{}
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Location,
			&i.Birthday,
			&i.HowMet,
			&i.Cadence,
			&i.LastContacted,
			&i.ProfilePhoto,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchContactsSorted = `-- name: SearchContactsSorted :many
SELECT c.id, c.full_name, c.location, c.birthday, c.how_met, c.cadence, c.last_contacted, c.profile_photo, c.deleted_at, c.created_at, c.updated_at, c.notes FROM contact c
LEFT JOIN (
  SELECT contact_id, string_agg(value, ' ') AS method_values
  FROM contact_method
  GROUP BY contact_id
) cm ON cm.contact_id = c.id
WHERE c.deleted_at IS NULL
  AND to_tsvector('english', c.full_name || ' ' || COALESCE(cm.method_values, '')) @@ plainto_tsquery('english', $1)
ORDER BY
  CASE WHEN $2 = 'name' AND $3 = 'asc' THEN c.full_name END ASC,
  CASE WHEN $2 = 'name' AND $3 = 'desc' THEN c.full_name END DESC,
  CASE WHEN $2 = 'location' AND $3 = 'asc' THEN COALESCE(c.location, '') END ASC,
  CASE WHEN $2 = 'location' AND $3 = 'desc' THEN COALESCE(c.location, '') END DESC,
  CASE WHEN $2 = 'birthday' AND $3 = 'asc' THEN c.birthday END ASC NULLS LAST,
  CASE WHEN $2 = 'birthday' AND $3 = 'desc' THEN c.birthday END DESC NULLS FIRST,
  CASE WHEN $2 = 'last_contacted' AND $3 = 'asc' THEN c.last_contacted END ASC NULLS LAST,
  CASE WHEN $2 = 'last_contacted' AND $3 = 'desc' THEN c.last_contacted END DESC NULLS FIRST
LIMIT $5 OFFSET $4
`

type SearchContactsSortedParams struct {
	SearchQuery string      `json:"search_query"`
	SortField   interface{} `json:"sort_field"`
	SortOrder   interface{} `json:"sort_order"`
	PageOffset  int32       `json:"page_offset"`
	PageLimit   int32       `json:"page_limit"`
}

func (q *Queries) SearchContactsSorted(ctx context.Context, arg SearchContactsSortedParams) ([]*Contact, error) {
	rows, err := q.db.Query(ctx, SearchContactsSorted,
		arg.SearchQuery,
		arg.SortField,
		arg.SortOrder,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Contact{}
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Location,
			&i.Birthday,
			&i.HowMet,
			&i.Cadence,
			&i.LastContacted,
			&i.ProfilePhoto,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SoftDeleteContact = `-- name: SoftDeleteContact :exec
UPDATE contact SET
  deleted_at = NOW(),
  updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteContact(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, SoftDeleteContact, id)
	return err
}

const UpdateContact = `-- name: UpdateContact :one
UPDATE contact SET
  full_name = $2,
  location = $3,
  birthday = $4,
  how_met = $5,
  cadence = $6,
  profile_photo = $7,
  notes = $8,
  updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, full_name, location, birthday, how_met, cadence, last_contacted, profile_photo, deleted_at, created_at, updated_at, notes
`

type UpdateContactParams struct {
	ID           pgtype.UUID `json:"id"`
	FullName     string      `json:"full_name"`
	Location     pgtype.Text `json:"location"`
	Birthday     pgtype.Date `json:"birthday"`
	HowMet       pgtype.Text `json:"how_met"`
	Cadence      pgtype.Text `json:"cadence"`
	ProfilePhoto pgtype.Text `json:"profile_photo"`
	Notes        pgtype.Text `json:"notes"`
}

func (q *Queries) UpdateContact(ctx context.Context, arg UpdateContactParams) (*Contact, error) {
	row := q.db.QueryRow(ctx, UpdateContact,
		arg.ID,
		arg.FullName,
		arg.Location,
		arg.Birthday,
		arg.HowMet,
		arg.Cadence,
		arg.ProfilePhoto,
		arg.Notes,
	)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Location,
		&i.Birthday,
		&i.HowMet,
		&i.Cadence,
		&i.LastContacted,
		&i.ProfilePhoto,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Notes,
	)
	return &i, err
}

const UpdateContactLastContacted = `-- name: UpdateContactLastContacted :exec
UPDATE contact SET
  last_contacted = $2,
  updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateContactLastContactedParams struct {
	ID            pgtype.UUID        `json:"id"`
	LastContacted pgtype.Timestamptz `json:"last_contacted"`
}

func (q *Queries) UpdateContactLastContacted(ctx context.Context, arg UpdateContactLastContactedParams) error {
	_, err := q.db.Exec(ctx, UpdateContactLastContacted, arg.ID, arg.LastContacted)
	return err
}
