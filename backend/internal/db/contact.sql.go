// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: contact.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountContacts = `-- name: CountContacts :one
SELECT COUNT(*) FROM contact WHERE deleted_at IS NULL
`

func (q *Queries) CountContacts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountContacts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateContact = `-- name: CreateContact :one
INSERT INTO contact (
  full_name, location, birthday, how_met, cadence, last_contacted, profile_photo
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
) RETURNING id, full_name, location, birthday, how_met, cadence, last_contacted, profile_photo, deleted_at, created_at, updated_at
`

type CreateContactParams struct {
	FullName      string      `json:"full_name"`
	Location      pgtype.Text `json:"location"`
	Birthday      pgtype.Date `json:"birthday"`
	HowMet        pgtype.Text `json:"how_met"`
	Cadence       pgtype.Text `json:"cadence"`
	LastContacted pgtype.Date `json:"last_contacted"`
	ProfilePhoto  pgtype.Text `json:"profile_photo"`
}

func (q *Queries) CreateContact(ctx context.Context, arg CreateContactParams) (*Contact, error) {
	row := q.db.QueryRow(ctx, CreateContact,
		arg.FullName,
		arg.Location,
		arg.Birthday,
		arg.HowMet,
		arg.Cadence,
		arg.LastContacted,
		arg.ProfilePhoto,
	)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Location,
		&i.Birthday,
		&i.HowMet,
		&i.Cadence,
		&i.LastContacted,
		&i.ProfilePhoto,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const GetContact = `-- name: GetContact :one

SELECT id, full_name, location, birthday, how_met, cadence, last_contacted, profile_photo, deleted_at, created_at, updated_at FROM contact 
WHERE id = $1 AND deleted_at IS NULL
`

// Contact queries
func (q *Queries) GetContact(ctx context.Context, id pgtype.UUID) (*Contact, error) {
	row := q.db.QueryRow(ctx, GetContact, id)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Location,
		&i.Birthday,
		&i.HowMet,
		&i.Cadence,
		&i.LastContacted,
		&i.ProfilePhoto,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const HardDeleteContact = `-- name: HardDeleteContact :exec
DELETE FROM contact WHERE id = $1
`

func (q *Queries) HardDeleteContact(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, HardDeleteContact, id)
	return err
}

const ListContacts = `-- name: ListContacts :many
SELECT id, full_name, location, birthday, how_met, cadence, last_contacted, profile_photo, deleted_at, created_at, updated_at FROM contact 
WHERE deleted_at IS NULL
LIMIT $1 OFFSET $2
`

type ListContactsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListContacts(ctx context.Context, arg ListContactsParams) ([]*Contact, error) {
	rows, err := q.db.Query(ctx, ListContacts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Contact{}
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Location,
			&i.Birthday,
			&i.HowMet,
			&i.Cadence,
			&i.LastContacted,
			&i.ProfilePhoto,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchContacts = `-- name: SearchContacts :many
SELECT c.id, c.full_name, c.location, c.birthday, c.how_met, c.cadence, c.last_contacted, c.profile_photo, c.deleted_at, c.created_at, c.updated_at FROM contact c
LEFT JOIN (
  SELECT contact_id, string_agg(value, ' ') AS method_values
  FROM contact_method
  GROUP BY contact_id
) cm ON cm.contact_id = c.id
WHERE c.deleted_at IS NULL
  AND to_tsvector('english', c.full_name || ' ' || COALESCE(cm.method_values, '')) @@ plainto_tsquery('english', $1)
ORDER BY ts_rank(
  to_tsvector('english', c.full_name || ' ' || COALESCE(cm.method_values, '')),
  plainto_tsquery('english', $1)
) DESC
LIMIT $2 OFFSET $3
`

type SearchContactsParams struct {
	PlaintoTsquery string `json:"plainto_tsquery"`
	Limit          int32  `json:"limit"`
	Offset         int32  `json:"offset"`
}

func (q *Queries) SearchContacts(ctx context.Context, arg SearchContactsParams) ([]*Contact, error) {
	rows, err := q.db.Query(ctx, SearchContacts, arg.PlaintoTsquery, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Contact{}
	for rows.Next() {
		var i Contact
		if err := rows.Scan(
			&i.ID,
			&i.FullName,
			&i.Location,
			&i.Birthday,
			&i.HowMet,
			&i.Cadence,
			&i.LastContacted,
			&i.ProfilePhoto,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SoftDeleteContact = `-- name: SoftDeleteContact :exec
UPDATE contact SET
  deleted_at = NOW(),
  updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteContact(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, SoftDeleteContact, id)
	return err
}

const UpdateContact = `-- name: UpdateContact :one
UPDATE contact SET
  full_name = $2,
  location = $3,
  birthday = $4,
  how_met = $5,
  cadence = $6,
  profile_photo = $7,
  updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, full_name, location, birthday, how_met, cadence, last_contacted, profile_photo, deleted_at, created_at, updated_at
`

type UpdateContactParams struct {
	ID           pgtype.UUID `json:"id"`
	FullName     string      `json:"full_name"`
	Location     pgtype.Text `json:"location"`
	Birthday     pgtype.Date `json:"birthday"`
	HowMet       pgtype.Text `json:"how_met"`
	Cadence      pgtype.Text `json:"cadence"`
	ProfilePhoto pgtype.Text `json:"profile_photo"`
}

func (q *Queries) UpdateContact(ctx context.Context, arg UpdateContactParams) (*Contact, error) {
	row := q.db.QueryRow(ctx, UpdateContact,
		arg.ID,
		arg.FullName,
		arg.Location,
		arg.Birthday,
		arg.HowMet,
		arg.Cadence,
		arg.ProfilePhoto,
	)
	var i Contact
	err := row.Scan(
		&i.ID,
		&i.FullName,
		&i.Location,
		&i.Birthday,
		&i.HowMet,
		&i.Cadence,
		&i.LastContacted,
		&i.ProfilePhoto,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const UpdateContactLastContacted = `-- name: UpdateContactLastContacted :exec
UPDATE contact SET
  last_contacted = $2,
  updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateContactLastContactedParams struct {
	ID            pgtype.UUID `json:"id"`
	LastContacted pgtype.Date `json:"last_contacted"`
}

func (q *Queries) UpdateContactLastContacted(ctx context.Context, arg UpdateContactLastContactedParams) error {
	_, err := q.db.Exec(ctx, UpdateContactLastContacted, arg.ID, arg.LastContacted)
	return err
}
