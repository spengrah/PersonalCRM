Add to backend/internal/api/handlers/contact.go after line 86:

// OverdueContactResponse represents an overdue contact with additional metadata
type OverdueContactResponse struct {
	ContactResponse
	DaysOverdue   int    `json:"days_overdue" example:"5"`
	NextDueDate   time.Time `json:"next_due_date" example:"2024-01-15T00:00:00Z"`
	SuggestedAction string `json:"suggested_action" example:"Send a quick check-in message"`
}

Add new handler after line 508:

// ListOverdueContacts retrieves contacts that are overdue for contact
// @Summary List overdue contacts  
// @Description Get contacts that are overdue based on their cadence settings
// @Tags contacts
// @Produce json
// @Success 200 {object} api.APIResponse{data=[]OverdueContactResponse} "Overdue contacts retrieved successfully"
// @Failure 500 {object} api.APIResponse{error=api.APIError} "Internal server error"
// @Router /contacts/overdue [get]
func (h *ContactHandler) ListOverdueContacts(c *gin.Context) {
	contacts, err := h.contactRepo.ListContacts(c.Request.Context(), repository.ListContactsParams{
		Limit:  1000, // Get all contacts to check cadence
		Offset: 0,
	})
	if err != nil {
		api.SendInternalError(c, "Failed to retrieve contacts")
		return
	}

	now := time.Now()
	var overdueContacts []OverdueContactResponse

	for _, contact := range contacts {
		// Skip contacts without cadence
		if contact.Cadence == nil {
			continue
		}

		cadence, err := reminder.ParseCadence(*contact.Cadence)
		if err != nil {
			continue // Skip invalid cadence
		}

		// Check if contact is overdue using environment-aware calculation
		if reminder.IsOverdueWithConfig(cadence, contact.LastContacted, contact.CreatedAt, now) {
			daysOverdue := reminder.GetOverdueDaysWithConfig(cadence, contact.LastContacted, contact.CreatedAt, now)
			nextDue := reminder.CalculateNextDueDate(cadence, contact.LastContacted, contact.CreatedAt)
			
			// Generate suggested action based on days overdue
			var suggestedAction string
			if daysOverdue <= 2 {
				suggestedAction = "Send a quick check-in message"
			} else if daysOverdue <= 7 {
				suggestedAction = "Schedule a call or coffee"
			} else if daysOverdue <= 30 {
				suggestedAction = "Send a meaningful update about your life"
			} else {
				suggestedAction = "Reconnect with something specific and personal"
			}

			overdueContact := OverdueContactResponse{
				ContactResponse: contactToResponse(&contact),
				DaysOverdue:     daysOverdue,
				NextDueDate:     nextDue,
				SuggestedAction: suggestedAction,
			}
			overdueContacts = append(overdueContacts, overdueContact)
		}
	}

	// Sort by days overdue (most overdue first)
	sort.Slice(overdueContacts, func(i, j int) bool {
		return overdueContacts[i].DaysOverdue > overdueContacts[j].DaysOverdue
	})

	api.SendSuccess(c, http.StatusOK, overdueContacts, nil)
}

Add imports:
"sort"
"personal-crm/backend/internal/reminder"
